<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>基地能量争夺战 - 优化版</title>
    <script src="./phaser.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            user-select: none;
            touch-action: manipulation;
        }
        
        body {
            font-family: 'Orbitron', 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #0c1a3a, #1d2b5c);
            color: #fff;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            padding: 10px;
            touch-action: none;
        }
        
        .container {
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 100%;
            max-width: 100%;
            gap: 10px;
            position: relative;
            height: 100vh;
        }
        
        .header-section {
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 100%;
            text-align: center;
            position: relative;
            padding: 5px 0;
            z-index: 100;
            background: rgba(0, 10, 30, 0.8);
            border-radius: 15px;
            margin-bottom: 5px;
            padding: 10px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.5);
            border: 1px solid #4dccff;
        }
        
        .title {
            font-size: 1.8rem;
            margin-bottom: 5px;
            background: linear-gradient(90deg, #4dccff, #00ff9d);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-shadow: 0 0 12px rgba(77, 204, 255, 0.5);
            letter-spacing: 1px;
            position: relative;
            animation: titleGlow 2s infinite alternate;
            font-weight: 700;
        }
        
        @keyframes titleGlow {
            0% { text-shadow: 0 0 12px rgba(77, 204, 255, 0.3); }
            100% { text-shadow: 0 0 20px rgba(77, 204, 255, 0.8); }
        }
        
        .title::after {
            content: '';
            position: absolute;
            bottom: -5px;
            left: 50%;
            transform: translateX(-50%);
            width: 150px;
            height: 3px;
            background: linear-gradient(90deg, #4dccff, #00ff9d);
            border-radius: 2px;
        }
        
        .subtitle {
            font-size: 0.85rem;
            margin-bottom: 10px;
            color: #aaccff;
            max-width: 95%;
            line-height: 1.4;
            text-shadow: 0 0 5px rgba(77, 204, 255, 0.3);
        }
        
        .difficulty {
            display: flex;
            justify-content: center;
            gap: 8px;
            margin-bottom: 10px;
            flex-wrap: wrap;
        }
        
        .difficulty-btn {
            background: linear-gradient(to bottom, #2a3a6a, #1a2a5a);
            color: #aaccff;
            padding: 8px 15px;
            border-radius: 20px;
            cursor: pointer;
            font-weight: bold;
            border: 2px solid #556699;
            transition: all 0.2s;
            font-size: 0.85rem;
            position: relative;
            overflow: hidden;
        }
        
        .difficulty-btn::after {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.2), transparent);
            transition: 0.5s;
        }
        
        .difficulty-btn:hover::after {
            left: 100%;
        }
        
        .difficulty-btn.active {
            background: linear-gradient(to bottom, #4dccff, #0072ff);
            color: white;
            border-color: #4dccff;
            box-shadow: 0 0 15px rgba(77, 204, 255, 0.7);
        }
        
        .game-container {
            position: relative;
            width: 100%;
            height: calc(100vh - 250px);
            max-height: 70vh;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.7);
            border-radius: 12px;
            overflow: hidden;
            border: 3px solid #445588;
            background: linear-gradient(135deg, #0c1a3a, #0f1f45);
            flex: 1;
        }
        
        #game-canvas {
            width: 100%;
            height: 100%;
            border-radius: 12px;
        }
        
        .ui-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
        }
        
        .game-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 15px;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 0 0 12px 12px;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.4);
            width: 100%;
            border-bottom: 2px solid #445588;
            z-index: 10;
            backdrop-filter: blur(5px);
        }
        
        .player-info {
            display: flex;
            flex-direction: column;
            align-items: center;
            min-width: 100px;
        }
        
        .player-name {
            font-size: 0.9rem;
            font-weight: bold;
            margin-bottom: 5px;
            color: #4dccff;
            text-shadow: 0 0 8px rgba(77, 204, 255, 0.7);
        }
        
        .energy-bar {
            width: 100%;
            height: 18px;
            background: #112244;
            border-radius: 10px;
            overflow: hidden;
            position: relative;
            border: 2px solid #334477;
            box-shadow: inset 0 0 6px rgba(0, 0, 0, 0.5);
        }
        
        .energy-fill {
            height: 100%;
            background: linear-gradient(to right, #00c6ff, #0072ff);
            border-radius: 8px;
            width: 100%;
            transition: width 0.5s ease;
        }
        
        .enemy-energy-fill {
            background: linear-gradient(to right, #ff416c, #ff4b2b);
        }
        
        .energy-display {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 0.75rem;
            color: white;
            text-shadow: 0 0 4px rgba(0, 0, 0, 0.8);
        }
        
        .timer {
            background: rgba(0, 0, 0, 0.6);
            padding: 6px 12px;
            border-radius: 20px;
            font-size: 0.9rem;
            font-weight: bold;
            color: #4dccff;
            border: 2px solid #445588;
            z-index: 10;
            backdrop-filter: blur(3px);
            box-shadow: 0 0 8px rgba(77, 204, 255, 0.3);
        }
        
        .game-content {
            flex: 1;
            position: relative;
        }
        
        .instructions {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.7);
            padding: 8px;
            border-radius: 8px;
            max-width: 180px;
            font-size: 0.75rem;
            line-height: 1.3;
            border: 2px solid #445588;
            z-index: 5;
            backdrop-filter: blur(4px);
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
        }
        
        .instructions h3 {
            color: #ffcc00;
            margin-bottom: 5px;
            text-align: center;
            font-size: 0.85rem;
        }
        
        .instructions ul {
            padding-left: 15px;
        }
        
        .instructions li {
            margin-bottom: 4px;
            font-size: 0.7rem;
        }
        
        .controls-container {
            position: absolute;
            bottom: 10px;
            right: 10px;
            display: flex;
            flex-direction: column;
            gap: 8px;
            z-index: 10;
        }
        
        .controls-toggle {
            align-self: flex-end;
            background: linear-gradient(to bottom, #2a3a6a, #1a2a5a);
            color: #aaccff;
            padding: 6px 12px;
            border-radius: 18px;
            cursor: pointer;
            font-weight: bold;
            border: 2px solid #556699;
            transition: all 0.2s;
            font-size: 0.8rem;
            pointer-events: all;
            margin-bottom: 5px;
            display: flex;
            align-items: center;
            gap: 5px;
        }
        
        .controls-toggle:hover {
            background: linear-gradient(to bottom, #3a4a7a, #2a3a6a);
        }
        
        .controls {
            display: flex;
            flex-direction: column;
            gap: 8px;
            padding: 10px;
            background: rgba(0, 0, 0, 0.6);
            border-radius: 12px;
            pointer-events: all;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.6);
            border: 2px solid #445588;
            backdrop-filter: blur(4px);
            transform: translateY(10px);
            transition: transform 0.3s ease, opacity 0.3s ease;
        }
        
        .controls.hidden {
            transform: translateY(20px);
            opacity: 0;
            pointer-events: none;
        }
        
        .control-row {
            display: flex;
            gap: 8px;
        }
        
        .control-btn {
            display: flex;
            align-items: center;
            background: linear-gradient(to bottom, #2a3a6a, #1a2a5a);
            padding: 8px 10px;
            border-radius: 10px;
            min-width: 140px;
            cursor: pointer;
            transition: all 0.2s;
            border: 2px solid #556699;
            box-shadow: 0 3px 6px rgba(0, 0, 0, 0.4);
            pointer-events: all;
            gap: 8px;
            position: relative;
            overflow: hidden;
        }
        
        .control-btn:hover {
            transform: translateY(-3px);
            background: linear-gradient(to bottom, #3a4a7a, #2a3a6a);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.5);
        }
        
        .control-btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }
        
        .control-btn.cooldown {
            position: relative;
        }
        
        .control-btn.cooldown::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.6);
            pointer-events: none;
        }
        
        .control-icon {
            font-size: 1.3rem;
            color: #4dccff;
            min-width: 24px;
            text-align: center;
        }
        
        .control-text {
            display: flex;
            flex-direction: column;
        }
        
        .control-name {
            font-size: 0.8rem;
            font-weight: bold;
            color: #aaccff;
        }
        
        .control-cost {
            font-size: 0.7rem;
            color: #ffd700;
            font-weight: bold;
        }
        
        .cooldown-indicator {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 0;
            background: rgba(255, 215, 0, 0.3);
            transition: height 0.1s linear;
        }
        
        .event-notice {
            position: absolute;
            top: 80px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.7);
            padding: 8px 20px;
            border-radius: 8px;
            font-size: 0.9rem;
            font-weight: bold;
            color: #ffcc00;
            text-align: center;
            z-index: 100;
            display: none;
            border: 2px solid #ffcc00;
            box-shadow: 0 0 15px rgba(255, 204, 0, 0.5);
            max-width: 90%;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            backdrop-filter: blur(4px);
            animation: pulse 1.5s infinite;
        }
        
        @keyframes pulse {
            0% { transform: translateX(-50%) scale(1); }
            50% { transform: translateX(-50%) scale(1.05); }
            100% { transform: translateX(-50%) scale(1); }
        }
        
        .message {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            padding: 20px 30px;
            border-radius: 15px;
            text-align: center;
            z-index: 200;
            display: none;
            border: 3px solid #ffcc00;
            box-shadow: 0 0 30px rgba(255, 204, 0, 0.8);
            pointer-events: all;
            width: 85%;
            max-width: 400px;
            backdrop-filter: blur(10px);
        }
        
        .message h2 {
            color: #ffcc00;
            margin-bottom: 15px;
            font-size: 1.8rem;
            text-shadow: 0 0 10px rgba(255, 204, 0, 0.8);
        }
        
        .message p {
            font-size: 1.1rem;
            margin-bottom: 20px;
            line-height: 1.5;
            color: #eef;
        }
        
        .message button {
            background: linear-gradient(to right, #ff416c, #ff4b2b);
            border: none;
            color: white;
            padding: 10px 30px;
            border-radius: 30px;
            font-size: 1rem;
            cursor: pointer;
            transition: all 0.3s;
            font-weight: bold;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.4);
            margin-top: 10px;
        }
        
        .message button:hover {
            transform: scale(1.05);
            box-shadow: 0 6px 15px rgba(255, 75, 43, 0.6);
            background: linear-gradient(to right, #ff5577, #ff6a4b);
        }
        
        .stats {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.6);
            padding: 8px;
            border-radius: 8px;
            border: 2px solid #445588;
            z-index: 5;
            backdrop-filter: blur(4px);
            text-align: center;
        }
        
        .stats h3 {
            color: #ffcc00;
            margin-bottom: 6px;
            font-size: 0.9rem;
        }
        
        .stat-item {
            display: flex;
            justify-content: space-between;
            margin-bottom: 4px;
            font-size: 0.75rem;
        }
        
        .stat-name {
            color: #aaccff;
        }
        
        .stat-value {
            color: #ffd700;
            font-weight: bold;
        }
        
        .sound-toggle {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.6);
            border: 2px solid #445588;
            border-radius: 50%;
            width: 32px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            z-index: 15;
            backdrop-filter: blur(4px);
        }
        
        .sound-toggle i {
            font-size: 1rem;
            color: #4dccff;
        }
        
        .energy-pulse {
            position: absolute;
            border-radius: 50%;
            pointer-events: none;
            z-index: 5;
            transform: scale(0);
            opacity: 0.8;
        }
        
        .skill-effect {
            position: absolute;
            border-radius: 50%;
            pointer-events: none;
            z-index: 10;
            opacity: 0;
            animation: skillEffect 1s forwards;
        }
        
        @keyframes skillEffect {
            0% { transform: scale(0); opacity: 0.8; }
            70% { opacity: 0.6; }
            100% { transform: scale(3); opacity: 0; }
        }
        
        .ai-skill-notice {
            position: absolute;
            bottom: 100px;
            right: 10px;
            background: rgba(0, 0, 0, 0.7);
            padding: 6px 12px;
            border-radius: 6px;
            font-size: 0.8rem;
            font-weight: bold;
            color: #ff416c;
            text-align: center;
            z-index: 100;
            display: none;
            border: 2px solid #ff416c;
            box-shadow: 0 0 12px rgba(255, 65, 108, 0.5);
            backdrop-filter: blur(4px);
        }
        
        /* 虚拟摇杆 */
        .joystick-container {
            position: absolute;
            bottom: 100px;
            left: 30px;
            width: 120px;
            height: 120px;
            z-index: 20;
            display: flex;
            justify-content: center;
            align-items: center;
            pointer-events: all;
        }
        
        .joystick-outer {
            width: 90px;
            height: 90px;
            background: rgba(40, 50, 90, 0.6);
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            border: 2px solid #556699;
            backdrop-filter: blur(4px);
        }
        
        .joystick-inner {
            width: 50px;
            height: 50px;
            background: linear-gradient(to bottom, #4dccff, #0072ff);
            border-radius: 50%;
            cursor: move;
            position: relative;
            box-shadow: 0 0 10px rgba(77, 204, 255, 0.5);
        }
        
        /* 移动端控制区域 */
        .mobile-controls {
            position: absolute;
            bottom: 20px;
            left: 0;
            right: 0;
            display: flex;
            justify-content: space-around;
            padding: 0 20px;
            z-index: 15;
            pointer-events: all;
        }
        
        .mobile-btn {
            width: 60px;
            height: 60px;
            background: rgba(40, 50, 90, 0.6);
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 1.5rem;
            color: #4dccff;
            border: 2px solid #556699;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.4);
            backdrop-filter: blur(4px);
            touch-action: manipulation;
        }
        
        /* 响应式设计 */
        @media (max-width: 768px) {
            .game-container {
                height: calc(100vh - 280px);
                max-height: 60vh;
            }
            
            .title {
                font-size: 1.5rem;
            }
            
            .subtitle {
                font-size: 0.8rem;
            }
            
            .controls {
                position: fixed;
                bottom: 10px;
                left: 10px;
                right: 10px;
                max-width: 100%;
                transform: none;
                flex-direction: row;
                flex-wrap: wrap;
                justify-content: center;
                padding: 8px;
            }
            
            .control-btn {
                min-width: calc(50% - 10px);
                padding: 6px 8px;
                gap: 6px;
            }
            
            .control-icon {
                font-size: 1.1rem;
            }
            
            .control-name {
                font-size: 0.75rem;
            }
            
            .control-cost {
                font-size: 0.65rem;
            }
            
            .instructions {
                max-width: 160px;
                font-size: 0.7rem;
                padding: 6px;
            }
            
            .instructions li {
                font-size: 0.65rem;
            }
            
            .player-name {
                font-size: 0.8rem;
            }
            
            .energy-bar {
                height: 16px;
            }
            
            .energy-display {
                font-size: 0.7rem;
            }
            
            .timer {
                font-size: 0.8rem;
                padding: 5px 10px;
            }
            
            .event-notice {
                top: 70px;
                font-size: 0.8rem;
                padding: 6px 15px;
            }
            
            .stats {
                top: 8px;
                right: 8px;
                padding: 6px;
            }
            
            .stats h3 {
                font-size: 0.8rem;
            }
            
            .stat-item {
                font-size: 0.7rem;
            }
            
            .mobile-controls {
                display: flex;
            }
            
            .joystick-container {
                display: block;
            }
        }
        
        @media (max-width: 480px) {
            .game-container {
                height: calc(100vh - 300px);
            }
            
            .title {
                font-size: 1.3rem;
            }
            
            .subtitle {
                font-size: 0.75rem;
            }
            
            .difficulty-btn {
                padding: 6px 10px;
                font-size: 0.8rem;
            }
            
            .control-btn {
                min-width: 100%;
            }
            
            .instructions {
                display: none;
            }
            
            .joystick-outer {
                width: 80px;
                height: 80px;
            }
            
            .joystick-inner {
                width: 40px;
                height: 40px;
            }
            
            .mobile-btn {
                width: 50px;
                height: 50px;
                font-size: 1.3rem;
            }
        }
        
        /* 横屏优化 */
        @media (orientation: landscape) and (max-height: 500px) {
            .header-section {
                padding: 2px 0;
            }
            
            .title {
                font-size: 1.2rem;
                margin-bottom: 2px;
            }
            
            .subtitle {
                display: none;
            }
            
            .difficulty {
                margin-bottom: 5px;
            }
            
            .game-container {
                height: calc(100vh - 120px);
            }
            
            .joystick-container {
                bottom: 60px;
                left: 20px;
            }
            
            .mobile-controls {
                bottom: 10px;
            }
        }
        
        /* 新添加的护盾效果 */
        .shield-ring {
            position: absolute;
            border-radius: 50%;
            pointer-events: none;
            z-index: 5;
            border: 3px solid #00ff9d;
            box-shadow: 0 0 15px rgba(0, 255, 157, 0.7);
            animation: shieldPulse 2s infinite;
        }
        
        @keyframes shieldPulse {
            0% { opacity: 0.8; box-shadow: 0 0 15px rgba(0, 255, 157, 0.7); }
            50% { opacity: 1; box-shadow: 0 0 25px rgba(0, 255, 157, 1); }
            100% { opacity: 0.8; box-shadow: 0 0 15px rgba(0, 255, 157, 0.7); }
        }
        
        /* 收集特效 */
        .collect-ring {
            position: absolute;
            border-radius: 50%;
            pointer-events: none;
            z-index: 5;
            border: 2px solid #4dccff;
            box-shadow: 0 0 10px rgba(77, 204, 255, 0.8);
            animation: collectExpand 0.8s forwards;
        }
        
        @keyframes collectExpand {
            0% { transform: scale(0.5); opacity: 1; }
            100% { transform: scale(3); opacity: 0; }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header-section">
            <h1 class="title">基地能量争夺战</h1>
            <div class="subtitle">控制能量核心，升级基地，摧毁敌方基地！终极优化版</div>
            
        
        </div>
        
        <div class="game-container">
            <div id="game-canvas"></div>
            
            <div class="ui-overlay">
                <div class="sound-toggle" id="sound-toggle">
                    <i class="fas fa-volume-up"></i>
                </div>
                
                <div class="game-header">
                    <div class="player-info">
                        <div class="player-name">玩家基地</div>
                        <div class="energy-bar">
                            <div class="energy-fill" id="player-energy" style="width: 100%"></div>
                            <div class="energy-display">能量: <span id="player-energy-value">10,000</span></div>
                        </div>
                    </div>
                    
                    <div class="timer">时间: <span id="timer">00:00</span></div>
                    
                    <div class="player-info">
                        <div class="player-name">敌方基地</div>
                        <div class="energy-bar">
                            <div class="energy-fill enemy-energy-fill" id="enemy-energy" style="width: 100%"></div>
                            <div class="energy-display">能量: <span id="enemy-energy-value">10,000</span></div>
                        </div>
                    </div>
                </div>
                
                <div class="game-content">
                    <div class="instructions">
                        <h3>游戏说明</h3>
                        <ul>
                            <li>指挥官自动收集能量核心</li>
                            <li>蓝核: +100 能量</li>
                            <li>金核: +500 能量</li>
                            <li>红核: +1000 能量</li>
                            <li>黑洞: 随机传送位置</li>
                            <li>使用能量升级基地或发动技能</li>
                            <li>摧毁敌方基地获得胜利</li>
                        </ul>
                    </div>
                    
                    <div class="stats">
                        <h3>基地状态</h3>
                        <div class="stat-item">
                            <span class="stat-name">攻击等级:</span>
                            <span class="stat-value" id="player-attack">1</span>
                        </div>
                        <div class="stat-item">
                            <span class="stat-name">防御等级:</span>
                            <span class="stat-value" id="player-defense">1</span>
                        </div>
                    </div>
                    
                    <div class="event-notice" id="event-notice">能量风暴！所有核心产出翻倍</div>
                    <div class="ai-skill-notice" id="ai-skill-notice">敌方使用了瞬间传送！</div>
                    
                    <div class="message" id="message">
                        <h2 id="message-title">游戏结束</h2>
                        <p id="message-content">你的基地被摧毁了！</p>
                        <button id="restart-btn">重新开始</button>
                    </div>
                    
                    <!-- 虚拟摇杆 -->
                    <div class="joystick-container" id="joystick-container" style="display: none;">
                        <div class="joystick-outer">
                            <div class="joystick-inner" id="joystick"></div>
                        </div>
                    </div>
                </div>
                
                <div class="controls-container">
                    <div class="controls-toggle" id="controls-toggle">
                        <i class="fas fa-chevron-down"></i> 技能面板
                    </div>
                    <div class="controls" id="controls">
                        <div class="control-row">
                            <div class="control-btn" id="upgrade-defense">
                                <div class="control-icon"><i class="fas fa-shield-alt"></i></div>
                                <div class="control-text">
                                    <div class="control-name">升级防御</div>
                                    <div class="control-cost">消耗: 1,000能量</div>
                                </div>
                            </div>
                            
                            <div class="control-btn" id="upgrade-attack">
                                <div class="control-icon"><i class="fas fa-bolt"></i></div>
                                <div class="control-text">
                                    <div class="control-name">升级攻击</div>
                                    <div class="control-cost">消耗: 800能量</div>
                                </div>
                            </div>
                        </div>
                        
                        <div class="control-row">
                            <div class="control-btn" id="use-clone">
                                <div class="control-icon"><i class="fas fa-clone"></i></div>
                                <div class="control-text">
                                    <div class="control-name">克隆指挥官</div>
                                    <div class="control-cost">消耗: 1,200能量</div>
                                </div>
                                <div class="cooldown-indicator" id="clone-cooldown"></div>
                            </div>
                            
                            <div class="control-btn" id="use-shield">
                                <div class="control-icon"><i class="fas fa-shield-virus"></i></div>
                                <div class="control-text">
                                    <div class="control-name">基地护盾</div>
                                    <div class="control-cost">消耗: 700能量</div>
                                </div>
                                <div class="cooldown-indicator" id="shield-cooldown"></div>
                            </div>
                        </div>
                        
                        <div class="control-row">
                            <div class="control-btn" id="use-nova">
                                <div class="control-icon"><i class="fas fa-radiation"></i></div>
                                <div class="control-text">
                                    <div class="control-name">能量新星</div>
                                    <div class="control-cost">消耗: 1,500能量</div>
                                </div>
                                <div class="cooldown-indicator" id="nova-cooldown"></div>
                            </div>
                            
                            <div class="control-btn" id="use-freeze">
                                <div class="control-icon"><i class="fas fa-snowflake"></i></div>
                                <div class="control-text">
                                    <div class="control-name">时间冻结</div>
                                    <div class="control-cost">消耗: 1,000能量</div>
                                </div>
                                <div class="cooldown-indicator" id="freeze-cooldown"></div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- 移动端控制按钮 -->
        <div class="mobile-controls" id="mobile-controls" style="display: none;">
            <div class="mobile-btn" id="mobile-shield"><i class="fas fa-shield-alt"></i></div>
            <div class="mobile-btn" id="mobile-attack"><i class="fas fa-bolt"></i></div>
            <div class="mobile-btn" id="mobile-clone"><i class="fas fa-clone"></i></div>
            <div class="mobile-btn" id="mobile-freeze"><i class="fas fa-snowflake"></i></div>
        </div>
    </div>

    <script>
        // 游戏配置
        const config = {
            type: Phaser.AUTO,
            width: 1200,
            height: 700,
            parent: 'game-canvas',
            scene: {
                preload: preload,
                create: create,
                update: update
            },
            physics: {
                default: 'arcade',
                arcade: {
                    gravity: { y: 0 },
                    debug: false
                }
            },
            backgroundColor: '#0c1a3a'
        };

        // 游戏状态
        const gameState = {
            playerEnergy: 10000, // 初始血量1万
            enemyEnergy: 10000,
            gameActive: true,
            playerDefense: 1,
            enemyDefense: 1,
            playerAttack: 1,
            enemyAttack: 1,
            eventActive: null,
            eventEndTime: 0,
            gameTime: 0,
            cores: [],
            difficulty: 'easy',
            playerShieldActive: false,
            playerShieldEndTime: 0,
            cloneCooldown: 0,
            shieldCooldown: 0,
            novaCooldown: 0,
            freezeCooldown: 0,
            enemyFrozen: false,
            enemyFreezeEndTime: 0,
            soundEnabled: true,
            clonedCommanders: [],
            playerFrozen: false,
            playerFreezeEndTime: 0,
            playerBaseShield: null,
            baseShieldParticles: [],
            isMobile: false,
            enemyCloneCooldown: 0,
            enemyShieldCooldown: 0
        };

        // 创建游戏实例
        const game = new Phaser.Game(config);
        let playerBase, enemyBase, playerCommander, enemyCommander;
        let energyCores = [], blackholes = [];
        let playerEnergyBar, enemyEnergyBar, playerEnergyText, enemyEnergyText;
        let timerText, eventNotice, aiSkillNotice;
        let upgradeDefenseBtn, upgradeAttackBtn, cloneBtn, shieldBtn, novaBtn, freezeBtn;
        let cloneCooldownIndicator, shieldCooldownIndicator, novaCooldownIndicator, freezeCooldownIndicator;
        let playerAttackText, playerDefenseText;
        let soundToggle, controlsToggle, controlsPanel;
        let backgroundStars = [];
        let joystick, joystickInner;
        let joystickOriginX, joystickOriginY;
        let joystickActive = false;

        // 难度设置
        const difficultySettings = {
            easy: { aiUpgradeInterval: 10000, aiSkillChance: 0.4 },
            normal: { aiUpgradeInterval: 8000, aiSkillChance: 0.6 },
            hard: { aiUpgradeInterval: 6000, aiSkillChance: 0.8 }
        };

        function preload() {
            // 预加载资源 - 优化后的图标
            // 玩家基地：六边形蓝色基地
            this.load.image('player-base', 'data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="100" height="100" viewBox="0 0 100 100"><polygon points="50,10 90,30 90,70 50,90 10,70 10,30" fill="%234dccff" stroke="%23007bff" stroke-width="5"/></svg>');
            
            // 敌方基地：六边形红色基地
            this.load.image('enemy-base', 'data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="100" height="100" viewBox="0 0 100 100"><polygon points="50,10 90,30 90,70 50,90 10,70 10,30" fill="%23ff416c" stroke="%23ff0000" stroke-width="5"/></svg>');
            
            // 玩家指挥官：三角形飞船
            this.load.image('player-commander', 'data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="50" height="50" viewBox="0 0 50 50"><rect x="15" y="15" width="20" height="20" rx="5" fill="%234dccff"/><rect x="20" y="35" width="10" height="10" fill="%234dccff"/></svg>');

            // 敌方指挥官：三角形飞船
            this.load.image('enemy-commander', 'data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="50" height="50" viewBox="0 0 50 50"><rect x="15" y="15" width="20" height="20" rx="5" fill="%23ff0000"/><rect x="20" y="35" width="10" height="10" fill="%23ff0000"/></svg>');
            
            // 克隆指挥官：三角形飞船
            this.load.image('clone-commander', 'data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="50" height="50" viewBox="0 0 50 50"><rect x="15" y="15" width="20" height="20" rx="5" fill="%2300cc66"/><rect x="20" y="35" width="10" height="10" fill="%2300cc66"/></svg>');
            
            // 能量核心
            this.load.image('core-blue', 'data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="40" height="40" viewBox="0 0 40 40"><circle cx="20" cy="20" r="18" fill="%230072ff"/><circle cx="20" cy="20" r="12" fill="%234dccff"/></svg>');
            this.load.image('core-gold', 'data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="40" height="40" viewBox="0 0 40 40"><circle cx="20" cy="20" r="18" fill="%23ffd700"/><circle cx="20" cy="20" r="12" fill="%23ffff00"/></svg>');
            this.load.image('core-red', 'data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="40" height="40" viewBox="0 0 40 40"><circle cx="20" cy="20" r="18" fill="%23ff416c"/><circle cx="20" cy="20" r="12" fill="%23ff9999"/></svg>');
            
            // 黑洞：多层圆环
            this.load.image('blackhole', 'data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="60" height="60" viewBox="0 0 60 60"><circle cx="30" cy="30" r="28" fill="%23000"/><circle cx="30" cy="30" r="24" fill="%23222"/><circle cx="30" cy="30" r="20" fill="%23444"/><circle cx="30" cy="30" r="16" fill="%23666"/><circle cx="30" cy="30" r="12" fill="%23888"/></svg>');
            
            // 星云背景
            this.load.image('nebula', 'data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="200" height="200" viewBox="0 0 200 200"><radialGradient id="grad" cx="50%" cy="50%" r="50%" fx="50%" fy="50%"><stop offset="0%" style="stop-color:rgba(77, 204, 255, 0.3);stop-opacity:1"/><stop offset="100%" style="stop-color:rgba(77, 204, 255, 0);stop-opacity:0"/></radialGradient><circle cx="100" cy="100" r="80" fill="url(#grad)"/></svg>');
            
            // 星星
            this.load.image('star', 'data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="10" height="10" viewBox="0 0 10 10"><circle cx="5" cy="5" r="2" fill="%23ffffff"/></svg>');
        }

        function create() {
            // 检测移动设备
            gameState.isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
            if (gameState.isMobile) {
                document.getElementById('joystick-container').style.display = 'block';
                document.getElementById('mobile-controls').style.display = 'flex';
                
                // 设置摇杆
                joystick = document.querySelector('.joystick-outer');
                joystickInner = document.getElementById('joystick');
                joystickOriginX = joystick.getBoundingClientRect().left + joystick.offsetWidth / 2;
                joystickOriginY = joystick.getBoundingClientRect().top + joystick.offsetHeight / 2;
                
                // 摇杆事件
                joystickInner.addEventListener('touchstart', handleJoystickStart);
                document.addEventListener('touchmove', handleJoystickMove);
                document.addEventListener('touchend', handleJoystickEnd);
                
                // 移动端按钮事件
                document.getElementById('mobile-shield').addEventListener('touchstart', () => useShield(this));
                document.getElementById('mobile-attack').addEventListener('touchstart', () => upgradeAttack(this));
                document.getElementById('mobile-clone').addEventListener('touchstart', () => useClone(this));
                document.getElementById('mobile-freeze').addEventListener('touchstart', () => useFreeze(this));
            }
            
            // 设置难度
            document.querySelectorAll('.difficulty-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    document.querySelectorAll('.difficulty-btn').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    gameState.difficulty = btn.id;
                });
            });
            
            // 音效开关
            soundToggle = document.getElementById('sound-toggle');
            soundToggle.addEventListener('click', () => {
                gameState.soundEnabled = !gameState.soundEnabled;
                const icon = soundToggle.querySelector('i');
                icon.className = gameState.soundEnabled ? 'fas fa-volume-up' : 'fas fa-volume-mute';
            });
            
            // 技能面板控制
            controlsToggle = document.getElementById('controls-toggle');
            controlsPanel = document.getElementById('controls');
            controlsToggle.addEventListener('click', () => {
                controlsPanel.classList.toggle('hidden');
                const icon = controlsToggle.querySelector('i');
                icon.className = controlsPanel.classList.contains('hidden') ? 
                    'fas fa-chevron-up' : 'fas fa-chevron-down';
            });
            
            // 初始化游戏物理世界
            this.physics.world.setBounds(0, 0, 1200, 700);
            
            // 创建基地 - 使用六边形设计
            playerBase = this.physics.add.sprite(200, 550, 'player-base').setScale(1.2).setTint(0x4dccff);
            playerBase.body.setImmovable(true);
            
            enemyBase = this.physics.add.sprite(1000, 150, 'enemy-base').setScale(1.2).setTint(0xff416c);
            enemyBase.body.setImmovable(true);
            
            // 创建指挥官 - 使用三角形飞船设计
            playerCommander = this.physics.add.sprite(200, 450, 'player-commander').setScale(1.5);
            playerCommander.body.setCollideWorldBounds(true);
            
            enemyCommander = this.physics.add.sprite(1000, 300, 'enemy-commander').setScale(1.5);
            enemyCommander.body.setCollideWorldBounds(true);
            
            // 创建能量核心
            createEnergyCores(this);
            
            // 创建黑洞
            createBlackholes(this);
            
            // 初始化UI元素
            playerEnergyBar = document.getElementById('player-energy');
            enemyEnergyBar = document.getElementById('enemy-energy');
            playerEnergyText = document.getElementById('player-energy-value');
            enemyEnergyText = document.getElementById('enemy-energy-value');
            timerText = document.getElementById('timer');
            eventNotice = document.getElementById('event-notice');
            aiSkillNotice = document.getElementById('ai-skill-notice');
            playerAttackText = document.getElementById('player-attack');
            playerDefenseText = document.getElementById('player-defense');
            
            // 添加事件监听
            upgradeDefenseBtn = document.getElementById('upgrade-defense');
            upgradeAttackBtn = document.getElementById('upgrade-attack');
            cloneBtn = document.getElementById('use-clone');
            shieldBtn = document.getElementById('use-shield');
            novaBtn = document.getElementById('use-nova');
            freezeBtn = document.getElementById('use-freeze');
            
            cloneCooldownIndicator = document.getElementById('clone-cooldown');
            shieldCooldownIndicator = document.getElementById('shield-cooldown');
            novaCooldownIndicator = document.getElementById('nova-cooldown');
            freezeCooldownIndicator = document.getElementById('freeze-cooldown');
            
            upgradeDefenseBtn.addEventListener('click', () => upgradeDefense(this));
            upgradeAttackBtn.addEventListener('click', () => upgradeAttack(this));
            cloneBtn.addEventListener('click', () => useClone(this));
            shieldBtn.addEventListener('click', () => useShield(this));
            novaBtn.addEventListener('click', () => useNova(this));
            freezeBtn.addEventListener('click', () => useFreeze(this));
            
            document.getElementById('restart-btn').addEventListener('click', restartGame);
            
            // 设置游戏时钟
            this.time.addEvent({
                delay: 1000,
                callback: () => {
                    if (gameState.gameActive) {
                        gameState.gameTime++;
                        updateTimer();
                        
                        // 更新冷却时间
                        if (gameState.cloneCooldown > 0) {
                            gameState.cloneCooldown--;
                            cloneCooldownIndicator.style.height = `${(gameState.cloneCooldown / 20) * 100}%`;
                        }
                        
                        if (gameState.shieldCooldown > 0) {
                            gameState.shieldCooldown--;
                            shieldCooldownIndicator.style.height = `${(gameState.shieldCooldown / 15) * 100}%`;
                        }
                        
                        if (gameState.novaCooldown > 0) {
                            gameState.novaCooldown--;
                            novaCooldownIndicator.style.height = `${(gameState.novaCooldown / 25) * 100}%`;
                        }
                        
                        if (gameState.freezeCooldown > 0) {
                            gameState.freezeCooldown--;
                            freezeCooldownIndicator.style.height = `${(gameState.freezeCooldown / 30) * 100}%`;
                        }
                        
                        // 更新AI冷却时间
                        if (gameState.enemyCloneCooldown > 0) gameState.enemyCloneCooldown--;
                        if (gameState.enemyShieldCooldown > 0) gameState.enemyShieldCooldown--;
                        
                        // 更新克隆指挥官
                        updateClonedCommanders(this);
                        
                        // 3分钟游戏时长控制
                        if (gameState.gameTime >= 180) {
                            if (gameState.playerEnergy > gameState.enemyEnergy) {
                                endGame('胜利！', '时间到，你的能量更多！');
                            } else if (gameState.playerEnergy < gameState.enemyEnergy) {
                                endGame('失败！', '时间到，敌方能量更多！');
                            } else {
                                endGame('平局！', '时间到，双方能量相同！');
                            }
                        }
                    }
                },
                loop: true
            });
            
            // 设置随机事件定时器
            this.time.addEvent({
                delay: 15000,
                callback: () => triggerRandomEvent(this),
                loop: true
            });
            
            // 设置AI升级定时器
            const aiSetting = difficultySettings[gameState.difficulty];
            this.time.addEvent({
                delay: aiSetting.aiUpgradeInterval,
                callback: () => aiUpgrade(this),
                loop: true
            });
            
            // 设置AI技能使用定时器（更频繁）
            this.time.addEvent({
                delay: 6000, // 6秒一次
                callback: () => aiUseSkill(this),
                loop: true
            });
        }

        function handleJoystickStart(e) {
            joystickActive = true;
            e.preventDefault();
        }

        function handleJoystickMove(e) {
            if (!joystickActive) return;
            e.preventDefault();
            
            const touch = e.touches[0];
            const touchX = touch.clientX;
            const touchY = touch.clientY;
            
            // 计算摇杆偏移量
            const dx = touchX - joystickOriginX;
            const dy = touchY - joystickOriginY;
            const distance = Math.sqrt(dx * dx + dy * dy);
            const maxDistance = 35; // 摇杆最大移动距离
            
            // 限制摇杆移动范围
            if (distance > maxDistance) {
                const angle = Math.atan2(dy, dx);
                joystickInner.style.transform = `translate(${Math.cos(angle) * maxDistance}px, ${Math.sin(angle) * maxDistance}px)`;
            } else {
                joystickInner.style.transform = `translate(${dx}px, ${dy}px)`;
            }
            
            // 移动指挥官
            if (playerCommander && !gameState.playerFrozen) {
                const speed = 200;
                playerCommander.body.setVelocity(
                    (dx / maxDistance) * speed,
                    (dy / maxDistance) * speed
                );
            }
        }

        function handleJoystickEnd(e) {
            joystickActive = false;
            joystickInner.style.transform = 'translate(0, 0)';
            
            if (playerCommander) {
                playerCommander.body.setVelocity(0);
            }
        }

        function createBackgroundDecorations(scene) {
            // 创建星云背景
            for (let i = 0; i < 6; i++) {
                const nebula = scene.add.sprite(
                    Phaser.Math.Between(0, 1200),
                    Phaser.Math.Between(0, 700),
                    'nebula'
                );
                nebula.setScale(Phaser.Math.FloatBetween(0.8, 1.5));
                nebula.setAlpha(Phaser.Math.FloatBetween(0.1, 0.3));
                nebula.setTint(Phaser.Math.RND.pick([0x4dccff, 0x9900ff, 0x00ff9d, 0xffcc00]));
                
                // 添加缓慢移动
                scene.tweens.add({
                    targets: nebula,
                    x: nebula.x + Phaser.Math.Between(-50, 50),
                    y: nebula.y + Phaser.Math.Between(-50, 50),
                    duration: Phaser.Math.Between(15000, 30000),
                    yoyo: true,
                    repeat: -1
                });
            }
            
            // 创建星星
            for (let i = 0; i < 150; i++) {
                const star = scene.add.sprite(
                    Phaser.Math.Between(0, 1200),
                    Phaser.Math.Between(0, 700),
                    'star'
                );
                star.setAlpha(Phaser.Math.FloatBetween(0.3, 0.8));
                star.setScale(Phaser.Math.FloatBetween(0.5, 1.2));
                backgroundStars.push(star);
                
                // 让星星闪烁
                scene.tweens.add({
                    targets: star,
                    alpha: Phaser.Math.FloatBetween(0.1, 0.5),
                    duration: Phaser.Math.Between(1000, 3000),
                    yoyo: true,
                    repeat: -1
                });
            }
        }

        function createEnergyCores(scene) {
            // 创建能量核心 - 避免与基地重叠
            const corePositions = [
                {x: 350, y: 250, type: 'blue'},
                {x: 600, y: 150, type: 'gold'},
                {x: 800, y: 400, type: 'blue'},
                {x: 300, y: 100, type: 'red'},
                {x: 700, y: 500, type: 'blue'},
                {x: 500, y: 350, type: 'gold'},
                {x: 900, y: 200, type: 'red'},
                {x: 450, y: 450, type: 'blue'}
            ];
            
            // 确保核心不会出现在基地附近
            corePositions.forEach(pos => {
                // 检查是否靠近玩家基地
                const distToPlayer = Phaser.Math.Distance.Between(pos.x, pos.y, playerBase.x, playerBase.y);
                const distToEnemy = Phaser.Math.Distance.Between(pos.x, pos.y, enemyBase.x, enemyBase.y);
                
                // 如果太靠近基地，重新生成位置
                if (distToPlayer < 150 || distToEnemy < 150) {
                    pos.x = Phaser.Math.Between(100, 1100);
                    pos.y = Phaser.Math.Between(100, 600);
                }
                
                let core;
                switch(pos.type) {
                    case 'blue':
                        core = scene.physics.add.sprite(pos.x, pos.y, 'core-blue');
                        core.energyValue = 100;
                        break;
                    case 'gold':
                        core = scene.physics.add.sprite(pos.x, pos.y, 'core-gold');
                        core.energyValue = 500;
                        break;
                    case 'red':
                        core = scene.physics.add.sprite(pos.x, pos.y, 'core-red');
                        core.energyValue = 1000;
                        break;
                }
                
                core.setScale(1.2);
                core.type = pos.type;
                core.collected = false;
                core.collectTimer = 0;
                
                // 添加收集光环
                const aura = scene.add.graphics();
                aura.lineStyle(3, 0xffffff, 0.6);
                aura.strokeCircle(core.x, core.y, 35);
                core.aura = aura;
                
                // 添加核心旋转动画
                scene.tweens.add({
                    targets: core,
                    angle: 360,
                    duration: 5000 + Math.random() * 5000,
                    repeat: -1,
                    ease: 'Linear'
                });
                
                energyCores.push(core);
                gameState.cores.push(core);
            });
        }
        
        function createBlackholes(scene) {
            // 创建黑洞 - 数量减少且避免与基地重叠
            blackholes = scene.physics.add.staticGroup();
            
            const blackholePositions = [
                {x: 450, y: 250},
                {x: 750, y: 450}
            ];
            
            blackholePositions.forEach(pos => {
                // 确保黑洞不会出现在基地附近
                const distToPlayer = Phaser.Math.Distance.Between(pos.x, pos.y, playerBase.x, playerBase.y);
                const distToEnemy = Phaser.Math.Distance.Between(pos.x, pos.y, enemyBase.x, enemyBase.y);
                
                if (distToPlayer < 200 || distToEnemy < 200) {
                    pos.x = Phaser.Math.Between(200, 1000);
                    pos.y = Phaser.Math.Between(100, 600);
                }
                
                const blackhole = blackholes.create(pos.x, pos.y, 'blackhole');
                blackhole.setScale(0.8);
                blackhole.setInteractive();
                
                // 添加黑洞引力效果
                const gravityField = scene.add.graphics();
                gravityField.lineStyle(2, 0x9900ff, 0.3);
                gravityField.strokeCircle(blackhole.x, blackhole.y, 80);
                blackhole.gravityField = gravityField;
                
                // 添加黑洞旋转动画
                scene.tweens.add({
                    targets: blackhole,
                    angle: 360,
                    duration: 8000,
                    repeat: -1,
                    ease: 'Linear'
                });
            });
        }
        
        function update() {
            if (!gameState.gameActive) return;
    
            // 更新玩家指挥官行为（如果没被冻结）
            if (!gameState.playerFrozen && !gameState.isMobile) {
                updateCommander(this, playerCommander, true);
            }
            
            // 更新克隆指挥官行为
            gameState.clonedCommanders.forEach(clone => {
                updateCommander(this, clone.commander, true);
            });
            
            // 更新敌方指挥官行为
            updateCommander(this, enemyCommander, false);
            
            // 检查基地攻击
            checkBaseAttacks(this);
            
            // 更新事件状态
            updateEventStatus(this);
            
            // 更新护盾状态
            updateShieldStatus(this);
            
            // 更新冻结状态
            updateFreezeStatus(this);
            
            // 检查黑洞效果
            checkBlackholes(this);
        }
        
        function updateCommander(scene, commander, isPlayer) {
            // 如果被冻结，则停止移动
            if ((!isPlayer && gameState.enemyFrozen) || 
                (isPlayer && gameState.playerFrozen)) {
                commander.body.setVelocity(0);
                return;
            }
            
            // 寻找最近的可收集核心
            let nearestCore = null;
            let minDistance = Infinity;
            
            energyCores.forEach(core => {
                if (!core.collected) {
                    const distance = Phaser.Math.Distance.Between(
                        commander.x, commander.y, 
                        core.x, core.y
                    );
                    
                    if (distance < minDistance) {
                        minDistance = distance;
                        nearestCore = core;
                    }
                }
            });
            
            // 向最近的核心移动
            if (nearestCore) {
                scene.physics.moveToObject(commander, nearestCore, 150);
                
                // 检查是否到达核心
                if (minDistance < 40) {
                    // 收集核心
                    if (!nearestCore.collected) {
                        nearestCore.collected = true;
                        
                        // 增加能量
                        let energyValue = nearestCore.energyValue;
                        
                        // 事件影响
                        if (gameState.eventActive === 'energyStorm') {
                            energyValue *= 2;
                        } else if (gameState.eventActive === 'energyDrain') {
                            energyValue = Math.floor(energyValue * 0.5);
                        }
                        
                        if (isPlayer) {
                            gameState.playerEnergy += energyValue;
                        } else {
                            gameState.enemyEnergy += energyValue;
                        }
                        
                        // 更新UI
                        updateEnergyUI();
                        
                        // 显示收集效果
                        showEnergyCollect(scene, commander.x, commander.y, energyValue, isPlayer);
                        
                        // 创建收集特效 - 改为简单的圆圈扩散
                        createCollectEffect(scene, commander.x, commander.y, isPlayer ? 0x4dccff : 0xff416c);
                        
                        // 红色核心可能爆炸
                        if (nearestCore.type === 'red' && Phaser.Math.Between(1, 100) <= 30) {
                            // 核心爆炸
                            createExplosion(scene, nearestCore.x, nearestCore.y);
                            
                            // 对指挥官造成伤害
                            const damage = 1000;
                            if (isPlayer) {
                                gameState.playerEnergy = Math.max(0, gameState.playerEnergy - damage);
                            } else {
                                gameState.enemyEnergy = Math.max(0, gameState.enemyEnergy - damage);
                            }
                            
                            updateEnergyUI();
                            
                            // 显示伤害效果
                            showDamage(scene, commander.x, commander.y - 30, damage);
                            
                            // 创建爆炸特效
                            createExplosionEffect(scene, commander.x, commander.y);
                        }
                        
                        // 重置核心（一段时间后）
                        scene.time.delayedCall(5000, () => {
                            nearestCore.collected = false;
                            // 修复光环重置问题
                            if (nearestCore.aura) {
                                nearestCore.aura.clear();
                                nearestCore.aura.lineStyle(3, 0xffffff, 0.6);
                                nearestCore.aura.strokeCircle(nearestCore.x, nearestCore.y, 35);
                            }
                        });
                        
                        // 移除光环
                        if (nearestCore.aura) {
                            nearestCore.aura.clear();
                        }
                    }
                }
            } else {
                // 没有核心时停止移动
                commander.body.setVelocity(0);
            }
        }
        
        function createCollectEffect(scene, x, y, color) {
            // 创建简单的圆圈扩散效果
            const ring = document.createElement('div');
            ring.className = 'collect-ring';
            ring.style.left = `${x - 25}px`;
            ring.style.top = `${y - 25}px`;
            ring.style.borderColor = `rgb(${(color >> 16) & 0xFF}, ${(color >> 8) & 0xFF}, ${color & 0xFF})`;
            ring.style.boxShadow = `0 0 10px rgb(${(color >> 16) & 0xFF}, ${(color >> 8) & 0xFF}, ${color & 0xFF})`;
            
            document.getElementById('game-canvas').parentElement.appendChild(ring);
            
            // 动画结束后移除元素
            setTimeout(() => {
                ring.remove();
            }, 800);
        }
        
        function createExplosion(scene, x, y) {
            // 简化的爆炸效果
            const explosion = scene.add.graphics();
            explosion.fillStyle(0xff0000, 0.8);
            explosion.fillCircle(x, y, 60);
            
            scene.tweens.add({
                targets: explosion,
                scale: 2,
                alpha: 0,
                duration: 800,
                onComplete: () => explosion.destroy()
            });
        }
        
        function createExplosionEffect(scene, x, y) {
            // 爆炸粒子效果
            for (let i = 0; i < 12; i++) {
                const angle = Math.random() * Math.PI * 2;
                const distance = Math.random() * 50;
                const particle = scene.add.graphics();
                particle.fillStyle(0xff4b2b, 1);
                particle.fillCircle(0, 0, 4);
                particle.x = x;
                particle.y = y;
                
                scene.tweens.add({
                    targets: particle,
                    x: x + Math.cos(angle) * distance,
                    y: y + Math.sin(angle) * distance,
                    alpha: 0,
                    duration: 800,
                    onComplete: () => particle.destroy()
                });
            }
        }
        
        function showEnergyCollect(scene, x, y, amount, isPlayer) {
            const color = isPlayer ? '#4dccff' : '#ff416c';
            const collectText = scene.add.text(
                x, y, 
                `+${amount.toLocaleString()}`, 
                { 
                    font: '20px Orbitron', 
                    fill: color,
                    fontWeight: 'bold',
                    stroke: '#000',
                    strokeThickness: 2
                }
            ).setOrigin(0.5);
            
            scene.tweens.add({
                targets: collectText,
                y: y - 80,
                alpha: 0,
                duration: 1200,
                onComplete: () => collectText.destroy()
            });
        }
        
        function showDamage(scene, x, y, amount) {
            const damageText = scene.add.text(
                x, y, 
                `-${amount.toLocaleString()}`, 
                { 
                    font: '20px Orbitron', 
                    fill: '#ff4b2b',
                    fontWeight: 'bold',
                    stroke: '#000',
                    strokeThickness: 2
                }
            ).setOrigin(0.5);
            
            scene.tweens.add({
                targets: damageText,
                y: y - 80,
                alpha: 0,
                duration: 1200,
                onComplete: () => damageText.destroy()
            });
        }
        
        function updateEnergyUI() {
            // 格式化数字显示
            const formatNumber = num => {
                if (num >= 1000000) return `${(num/1000000).toFixed(1)}M`;
                if (num >= 1000) return `${(num/1000).toFixed(1)}K`;
                return num;
            };
            
            // 更新玩家能量（最大1万）
            const playerPercent = Math.min(100, (gameState.playerEnergy / 10000) * 100);
            playerEnergyBar.style.width = `${playerPercent}%`;
            playerEnergyText.textContent = formatNumber(gameState.playerEnergy);
            
            // 更新敌方能量（最大1万）
            const enemyPercent = Math.min(100, (gameState.enemyEnergy / 10000) * 100);
            enemyEnergyBar.style.width = `${enemyPercent}%`;
            enemyEnergyText.textContent = formatNumber(gameState.enemyEnergy);
            
            // 更新状态显示
            playerAttackText.textContent = gameState.playerAttack;
            playerDefenseText.textContent = gameState.playerDefense;
            
            // 检查游戏结束
            if (gameState.playerEnergy <= 0) {
                gameState.playerEnergy = 0;
                endGame('失败！', '你的基地能量耗尽！');
            }
            
            if (gameState.enemyEnergy <= 0) {
                gameState.enemyEnergy = 0;
                endGame('胜利！', '你成功摧毁了敌方基地！');
            }
        }
        
        function updateTimer() {
            const minutes = Math.floor(gameState.gameTime / 60);
            const seconds = gameState.gameTime % 60;
            timerText.textContent = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
        }
        
        function checkBaseAttacks(scene) {
            // 玩家基地攻击
            if (scene.time.now % 2000 < 50 && gameState.playerAttack > 0) {
                // 考虑防御等级
                const damage = Math.floor(18 * gameState.playerAttack / gameState.enemyDefense);
                gameState.enemyEnergy = Math.max(0, gameState.enemyEnergy - damage);
                updateEnergyUI();
                
                // 显示攻击效果
                createLaserBeam(scene, playerBase, enemyBase, 0x4dccff);
                
                // 显示伤害数字
                showDamage(scene, enemyBase.x, enemyBase.y - 50, damage);
            }
            
            // 敌方基地攻击
            if (scene.time.now % 2000 < 50 && gameState.enemyAttack > 0) {
                // 考虑防御等级和护盾
                let damage = Math.floor(18 * gameState.enemyAttack / gameState.playerDefense);
                
                // 如果护盾激活，减免50%伤害
                if (gameState.playerShieldActive) {
                    damage = Math.floor(damage * 0.5);
                }
                
                gameState.playerEnergy = Math.max(0, gameState.playerEnergy - damage);
                updateEnergyUI();
                
                // 显示攻击效果
                createLaserBeam(scene, enemyBase, playerBase, 0xff416c);
                
                // 显示伤害数字
                showDamage(scene, playerBase.x, playerBase.y - 50, damage);
            }
        }
        
        function createLaserBeam(scene, from, to, color) {
            const laser = scene.add.graphics();
            laser.lineStyle(4, color, 0.8);
            laser.lineBetween(from.x, from.y, to.x, to.y);
            
            scene.tweens.add({
                targets: laser,
                alpha: 0,
                duration: 300,
                onComplete: () => laser.destroy()
            });
        }
        
        function upgradeDefense(scene) {
            if (gameState.playerEnergy < 1000) return;
            
            gameState.playerEnergy -= 1000;
            gameState.playerDefense++;
            updateEnergyUI();
            
            // 创建技能特效
            createUpgradeEffect(scene, playerBase.x, playerBase.y, 0x4dccff);
        }
        
        function upgradeAttack(scene) {
            if (gameState.playerEnergy < 800) return;
            
            gameState.playerEnergy -= 800;
            gameState.playerAttack++;
            updateEnergyUI();
            
            // 创建技能特效
            createUpgradeEffect(scene, playerBase.x, playerBase.y, 0xff0000);
        }
        
        function createUpgradeEffect(scene, x, y, color) {
            // 创建升级粒子效果
            for (let i = 0; i < 16; i++) {
                const angle = Math.random() * Math.PI * 2;
                const distance = Math.random() * 80;
                const particle = scene.add.graphics();
                particle.fillStyle(color, 1);
                particle.fillCircle(0, 0, 6);
                particle.x = x;
                particle.y = y;
                
                scene.tweens.add({
                    targets: particle,
                    x: x + Math.cos(angle) * distance,
                    y: y + Math.sin(angle) * distance,
                    alpha: 0,
                    duration: 1000,
                    onComplete: () => particle.destroy()
                });
            }
        }
        
        function useClone(scene) {
            if (gameState.playerEnergy < 1200 || gameState.cloneCooldown > 0) return;
            
            gameState.playerEnergy -= 1200;
            gameState.cloneCooldown = 20;
            cloneCooldownIndicator.style.height = '100%';
            updateEnergyUI();
            
            // 创建克隆指挥官
            const clone = scene.physics.add.sprite(
                playerBase.x + Phaser.Math.Between(-100, 100),
                playerBase.y + Phaser.Math.Between(-100, 100),
                'clone-commander'
            ).setScale(1.5);
            clone.body.setCollideWorldBounds(true);
            
            // 添加到克隆列表
            gameState.clonedCommanders.push({
                commander: clone,
                createdTime: scene.time.now,
                duration: 15000
            });
            
            // 添加克隆特效
            createCloneEffect(scene, clone.x, clone.y);
        }
        
        function createCloneEffect(scene, x, y) {
            // 克隆粒子效果
            for (let i = 0; i < 25; i++) {
                const angle = Math.random() * Math.PI * 2;
                const distance = Math.random() * 70;
                const particle = scene.add.graphics();
                particle.fillStyle(0x00ff9d, 1);
                particle.fillCircle(0, 0, 5);
                particle.x = x;
                particle.y = y;
                
                scene.tweens.add({
                    targets: particle,
                    x: x + Math.cos(angle) * distance,
                    y: y + Math.sin(angle) * distance,
                    alpha: 0,
                    duration: 1000,
                    onComplete: () => particle.destroy()
                });
            }
        }
        
        function updateClonedCommanders(scene) {
            for (let i = gameState.clonedCommanders.length - 1; i >= 0; i--) {
                const clone = gameState.clonedCommanders[i];
                
                // 检查克隆是否过期
                if (scene.time.now > clone.createdTime + clone.duration) {
                    // 移除克隆
                    createDisappearEffect(scene, clone.commander.x, clone.commander.y);
                    clone.commander.destroy();
                    gameState.clonedCommanders.splice(i, 1);
                }
            }
        }
        
        function createDisappearEffect(scene, x, y) {
            // 消失特效
            for (let i = 0; i < 20; i++) {
                const angle = Math.random() * Math.PI * 2;
                const distance = Math.random() * 60;
                const particle = scene.add.graphics();
                particle.fillStyle(0x00ff9d, 1);
                particle.fillCircle(0, 0, 4);
                particle.x = x;
                particle.y = y;
                
                scene.tweens.add({
                    targets: particle,
                    x: x + Math.cos(angle) * distance,
                    y: y + Math.sin(angle) * distance,
                    alpha: 0,
                    duration: 800,
                    onComplete: () => particle.destroy()
                });
            }
        }
        
        function useShield(scene) {
            if (gameState.playerEnergy < 700 || gameState.shieldCooldown > 0) return;
            
            gameState.playerEnergy -= 700;
            gameState.shieldCooldown = 15;
            shieldCooldownIndicator.style.height = '100%';
            updateEnergyUI();
            
            // 激活基地护盾
            gameState.playerShieldActive = true;
            gameState.playerShieldEndTime = scene.time.now + 5000;
            
            // 显示护盾效果 - 改为稳定的绿色光环
            createShieldEffect(scene, playerBase.x, playerBase.y);
        }
        
        function createShieldEffect(scene, x, y) {
            // 移除之前的护盾（如果有）
            if (gameState.playerBaseShield) {
                gameState.playerBaseShield.remove();
            }
            
            // 创建护盾环 - 使用CSS动画
            const shieldRing = document.createElement('div');
            shieldRing.className = 'shield-ring';
            shieldRing.style.width = '130px';
            shieldRing.style.height = '130px';
            shieldRing.style.left = `${x - 65}px`;
            shieldRing.style.top = `${y - 65}px`;
            
            document.getElementById('game-canvas').parentElement.appendChild(shieldRing);
            gameState.playerBaseShield = shieldRing;
            
            // 5秒后销毁护盾
            scene.time.delayedCall(5000, () => {
                if (shieldRing) {
                    shieldRing.remove();
                }
            });
        }
        
        function useNova(scene) {
            if (gameState.playerEnergy < 1500 || gameState.novaCooldown > 0) return;
            
            gameState.playerEnergy -= 1500;
            gameState.novaCooldown = 25;
            novaCooldownIndicator.style.height = '100%';
            updateEnergyUI();
            
            // 创建能量新星效果
            createNovaEffect(scene, playerCommander.x, playerCommander.y);
            
            // 对敌方基地造成冲击波伤害
            const distanceToEnemyBase = Phaser.Math.Distance.Between(
                playerCommander.x, playerCommander.y,
                enemyBase.x, enemyBase.y
            );
            
            // 伤害随距离衰减
            const maxDamage = 2500;
            const minDamage = 500;
            const damage = Math.max(minDamage, maxDamage - (distanceToEnemyBase / 5));
            
            gameState.enemyEnergy = Math.max(0, gameState.enemyEnergy - damage);
            updateEnergyUI();
            
            // 显示伤害效果
            showDamage(scene, enemyBase.x, enemyBase.y - 50, damage);
            
            // 创建冲击波效果
            createShockwave(scene, playerCommander.x, playerCommander.y, enemyBase.x, enemyBase.y);
        }
        
        function createShockwave(scene, fromX, fromY, toX, toY) {
            // 创建冲击波
            const shockwave = scene.add.graphics();
            shockwave.lineStyle(4, 0xff0000, 0.7);
            shockwave.lineBetween(fromX, fromY, toX, toY);
            
            // 添加粒子效果
            for (let i = 0; i < 30; i++) {
                const progress = i / 30;
                const x = fromX + (toX - fromX) * progress;
                const y = fromY + (toY - fromY) * progress;
                
                const particle = scene.add.graphics();
                particle.fillStyle(0xff0000, 1);
                particle.fillCircle(0, 0, 3);
                particle.x = x;
                particle.y = y;
                
                scene.tweens.add({
                    targets: particle,
                    scale: 0,
                    alpha: 0,
                    duration: 800,
                    delay: i * 20,
                    onComplete: () => particle.destroy()
                });
            }
            
            // 0.5秒后消失
            scene.time.delayedCall(500, () => {
                shockwave.destroy();
            });
        }

        function createNovaEffect(scene, x, y) {
            // 新星粒子效果
            for (let i = 0; i < 50; i++) {
                const angle = Math.random() * Math.PI * 2;
                const distance = Math.random() * 300;
                const particle = scene.add.graphics();
                particle.fillStyle(0x4dccff, 1);
                particle.fillCircle(0, 0, 4);
                particle.x = x;
                particle.y = y;
                
                scene.tweens.add({
                    targets: particle,
                    x: x + Math.cos(angle) * distance,
                    y: y + Math.sin(angle) * distance,
                    alpha: 0,
                    duration: 1500,
                    onComplete: () => particle.destroy()
                });
            }
            
            // 冲击波效果
            const shockwave = scene.add.graphics();
            shockwave.lineStyle(4, 0x4dccff, 0.8);
            shockwave.strokeCircle(x, y, 10);
            
            scene.tweens.add({
                targets: shockwave,
                scale: 30,
                alpha: 0,
                duration: 1000,
                onComplete: () => shockwave.destroy()
            });
        }
        
        function useFreeze(scene) {
            if (gameState.playerEnergy < 1000 || gameState.freezeCooldown > 0) return;
            
            gameState.playerEnergy -= 1000;
            gameState.freezeCooldown = 30;
            freezeCooldownIndicator.style.height = '100%';
            updateEnergyUI();
            
            // 冻结敌方指挥官
            gameState.enemyFrozen = true;
            gameState.enemyFreezeEndTime = scene.time.now + 5000;
            
            // 显示冻结效果
            createFreezeEffect(scene, enemyCommander.x, enemyCommander.y);
        }
        
        function createFreezeEffect(scene, x, y) {
            const freeze = scene.add.graphics();
            freeze.lineStyle(3, 0x4dccff, 0.8);
            freeze.strokeCircle(x, y, 35);
            
            scene.tweens.add({
                targets: freeze,
                scale: 1.2,
                alpha: 0.5,
                duration: 500,
                yoyo: true,
                repeat: -1
            });
            
            // 5秒后销毁特效
            scene.time.delayedCall(5000, () => freeze.destroy());
            
            // 添加雪花粒子
            for (let i = 0; i < 20; i++) {
                const particle = scene.add.graphics();
                particle.fillStyle(0x4dccff, 1);
                particle.fillCircle(0, 0, 2);
                particle.x = x;
                particle.y = y;
                
                scene.tweens.add({
                    targets: particle,
                    x: x + Phaser.Math.Between(-40, 40),
                    y: y + Phaser.Math.Between(-40, 40),
                    alpha: 0,
                    duration: 2000,
                    delay: i * 100,
                    onComplete: () => particle.destroy()
                });
            }
        }
        
        function triggerRandomEvent(scene) {
            if (!gameState.gameActive) return;
            
            const events = [
                { 
                    name: 'energyStorm', 
                    title: '能量风暴', 
                    message: '所有能量核心产出翻倍！',
                    color: '#4dccff',
                    duration: 10000
                },
                { 
                    name: 'timeWarp', 
                    title: '时间扭曲', 
                    message: '指挥官移动速度大幅提升！',
                    color: '#ffcc00',
                    duration: 8000
                },
                { 
                    name: 'energyDrain', 
                    title: '能量枯竭', 
                    message: '所有核心产出减半！',
                    color: '#ff416c',
                    duration: 10000
                },
                { 
                    name: 'blackhole', 
                    title: '黑洞出现', 
                    message: '地图中出现了新的黑洞！',
                    color: '#9900ff',
                    duration: 0
                },
                { 
                    name: 'coreSurge', 
                    title: '核心爆发', 
                    message: '地图上出现了额外能量核心！',
                    color: '#00ff9d',
                    duration: 0
                },
                { 
                    name: 'defenseBoost', 
                    title: '防御增强', 
                    message: '玩家防御力暂时提升！',
                    color: '#4dccff',
                    duration: 8000
                },
                { 
                    name: 'blackholeConsume', 
                    title: '黑洞吞噬', 
                    message: '黑洞引力增强！小心被吞噬！',
                    color: '#9900ff',
                    duration: 8000
                },
                { 
                    name: 'attackBoost', 
                    title: '攻击强化', 
                    message: '玩家攻击力暂时提升！',
                    color: '#ff416c',
                    duration: 8000
                },
                { 
                    name: 'supernova', 
                    title: '超新星爆发', 
                    message: '所有核心重置为红核！',
                    color: '#ff6600',
                    duration: 0
                },
                { 
                    name: 'commanderBoost', 
                    title: '指挥官强化', 
                    message: '指挥官移动速度提升50%！',
                    color: '#00ff9d',
                    duration: 8000
                },
                { 
                    name: 'commanderSlow', 
                    title: '指挥官减速', 
                    message: '指挥官移动速度降低50%！',
                    color: '#ff416c',
                    duration: 8000
                }
            ];
            
            const event = Phaser.Math.RND.pick(events);
            gameState.eventActive = event.name;
            gameState.eventEndTime = scene.time.now + event.duration;
            
            // 显示事件通知
            eventNotice.textContent = `${event.title}: ${event.message}`;
            eventNotice.style.display = 'block';
            eventNotice.style.borderColor = event.color;
            eventNotice.style.boxShadow = `0 0 15px ${event.color}`;
            
            // 应用事件效果
            switch(event.name) {
                case 'energyStorm':
                    // 数值效果已在实际收集时处理
                    break;
                    
                case 'timeWarp':
                    // 加速效果
                    playerCommander.body.speed = 300;
                    enemyCommander.body.speed = 300;
                    gameState.clonedCommanders.forEach(clone => {
                        clone.commander.body.speed = 300;
                    });
                    break;
                    
                case 'energyDrain':
                    // 数值效果已在实际收集时处理
                    break;
                    
                case 'blackhole':
                    // 创建新黑洞
                    createNewBlackhole(scene);
                    break;
                    
                case 'coreSurge':
                    // 创建额外核心
                    createAdditionalCores(scene);
                    break;
                    
                case 'defenseBoost':
                    // 临时提升防御
                    gameState.playerDefense += 2;
                    playerDefenseText.textContent = gameState.playerDefense;
                    createUpgradeEffect(scene, playerBase.x, playerBase.y, 0x4dccff);
                    break;
                    
                case 'attackBoost':
                    // 临时提升攻击
                    gameState.playerAttack += 2;
                    playerAttackText.textContent = gameState.playerAttack;
                    createUpgradeEffect(scene, playerBase.x, playerBase.y, 0xff0000);
                    break;
                    
                case 'blackholeConsume':
                    // 增强黑洞引力范围
                    blackholes.getChildren().forEach(blackhole => {
                        blackhole.gravityField.clear();
                        blackhole.gravityField.lineStyle(3, 0x9900ff, 0.5);
                        blackhole.gravityField.strokeCircle(blackhole.x, blackhole.y, 120);
                    });
                    break;
                    
                case 'supernova':
                    // 将所有核心重置为红核
                    energyCores.forEach(core => {
                        core.setTexture('core-red');
                        core.energyValue = 1000;
                        core.type = 'red';
                    });
                    break;
                    
                case 'commanderBoost':
                    // 加速效果
                    playerCommander.body.speed = 225;
                    enemyCommander.body.speed = 225;
                    gameState.clonedCommanders.forEach(clone => {
                        clone.commander.body.speed = 225;
                    });
                    break;
                    
                case 'commanderSlow':
                    // 减速效果
                    playerCommander.body.speed = 75;
                    enemyCommander.body.speed = 75;
                    gameState.clonedCommanders.forEach(clone => {
                        clone.commander.body.speed = 75;
                    });
                    break;
            }
            
            // 隐藏通知
            scene.time.delayedCall(4000, () => {
                eventNotice.style.display = 'none';
            });
        }
        
        function createNewBlackhole(scene) {
            const blackhole = blackholes.create(
                Phaser.Math.Between(200, 1000),
                Phaser.Math.Between(100, 600),
                'blackhole'
            );
            blackhole.setScale(0.8);
            
            // 添加黑洞引力效果
            const gravityField = scene.add.graphics();
            gravityField.lineStyle(2, 0x9900ff, 0.3);
            gravityField.strokeCircle(blackhole.x, blackhole.y, 80);
            blackhole.gravityField = gravityField;
            
            // 添加黑洞旋转动画
            scene.tweens.add({
                targets: blackhole,
                angle: 360,
                duration: 8000,
                repeat: -1,
                ease: 'Linear'
            });
            
            // 创建黑洞出现效果
            createBlackholeEffect(scene, blackhole.x, blackhole.y);
        }
        
        function createBlackholeEffect(scene, x, y) {
            // 黑洞出现特效
            for (let i = 0; i < 25; i++) {
                const angle = Math.random() * Math.PI * 2;
                const distance = Math.random() * 100;
                const particle = scene.add.graphics();
                particle.fillStyle(0x9900ff, 1);
                particle.fillCircle(0, 0, 5);
                particle.x = x;
                particle.y = y;
                
                scene.tweens.add({
                    targets: particle,
                    x: x + Math.cos(angle) * distance,
                    y: y + Math.sin(angle) * distance,
                    alpha: 0,
                    duration: 1200,
                    onComplete: () => particle.destroy()
                });
            }
        }
        
        function createAdditionalCores(scene) {
            for (let i = 0; i < 3; i++) {
                const coreType = Phaser.Math.RND.pick(['blue', 'gold', 'red']);
                const x = Phaser.Math.Between(100, 1100);
                const y = Phaser.Math.Between(100, 600);
                
                // 确保不会出现在基地附近
                const distToPlayer = Phaser.Math.Distance.Between(x, y, playerBase.x, playerBase.y);
                const distToEnemy = Phaser.Math.Distance.Between(x, y, enemyBase.x, enemyBase.y);
                
                if (distToPlayer < 150 || distToEnemy < 150) continue;
                
                let core;
                switch(coreType) {
                    case 'blue':
                        core = scene.physics.add.sprite(x, y, 'core-blue');
                        core.energyValue = 100;
                        break;
                    case 'gold':
                        core = scene.physics.add.sprite(x, y, 'core-gold');
                        core.energyValue = 500;
                        break;
                    case 'red':
                        core = scene.physics.add.sprite(x, y, 'core-red');
                        core.energyValue = 1000;
                        break;
                }
                
                core.setScale(1.2);
                core.type = coreType;
                core.collected = false;
                
                // 添加收集光环
                const aura = scene.add.graphics();
                aura.lineStyle(3, 0xffffff, 0.6);
                aura.strokeCircle(core.x, core.y, 35);
                core.aura = aura;
                
                // 添加核心旋转动画
                scene.tweens.add({
                    targets: core,
                    angle: 360,
                    duration: 5000 + Math.random() * 5000,
                    repeat: -1,
                    ease: 'Linear'
                });
                
                energyCores.push(core);
                gameState.cores.push(core);
                
                // 创建核心出现效果
                createCoreEffect(scene, x, y, coreType);
            }
        }
        
        function createCoreEffect(scene, x, y, type) {
            const color = type === 'blue' ? 0x0072ff : type === 'gold' ? 0xffd700 : 0xff416c;
            
            // 核心出现特效
            for (let i = 0; i < 20; i++) {
                const angle = Math.random() * Math.PI * 2;
                const distance = Math.random() * 80;
                const particle = scene.add.graphics();
                particle.fillStyle(color, 1);
                particle.fillCircle(0, 0, 4);
                particle.x = x;
                particle.y = y;
                
                scene.tweens.add({
                    targets: particle,
                    x: x + Math.cos(angle) * distance,
                    y: y + Math.sin(angle) * distance,
                    alpha: 0,
                    duration: 1000,
                    onComplete: () => particle.destroy()
                });
            }
        }
        
        function updateEventStatus(scene) {
            if (gameState.eventActive && scene.time.now > gameState.eventEndTime) {
                // 结束事件效果
                switch(gameState.eventActive) {
                    case 'timeWarp':
                        // 恢复原始速度
                        playerCommander.body.speed = 150;
                        enemyCommander.body.speed = 150;
                        gameState.clonedCommanders.forEach(clone => {
                            clone.commander.body.speed = 150;
                        });
                        break;
                        
                    case 'defenseBoost':
                        gameState.playerDefense -= 2;
                        playerDefenseText.textContent = gameState.playerDefense;
                        break;
                        
                    case 'attackBoost':
                        gameState.playerAttack -= 2;
                        playerAttackText.textContent = gameState.playerAttack;
                        break;
                        
                    case 'blackholeConsume':
                        // 恢复黑洞引力范围
                        blackholes.getChildren().forEach(blackhole => {
                            blackhole.gravityField.clear();
                            blackhole.gravityField.lineStyle(2, 0x9900ff, 0.3);
                            blackhole.gravityField.strokeCircle(blackhole.x, blackhole.y, 80);
                        });
                        break;
                        
                    case 'commanderBoost':
                    case 'commanderSlow':
                        // 恢复原始速度
                        playerCommander.body.speed = 150;
                        enemyCommander.body.speed = 150;
                        gameState.clonedCommanders.forEach(clone => {
                            clone.commander.body.speed = 150;
                        });
                        break;
                }
                
                gameState.eventActive = null;
            }
        }

        function updateShieldStatus(scene) {
            if (gameState.playerShieldActive && scene.time.now > gameState.playerShieldEndTime) {
                gameState.playerShieldActive = false;
                
                // 移除护盾效果
                if (gameState.playerBaseShield) {
                    gameState.playerBaseShield.remove();
                }
            }
        }
        
        function updateFreezeStatus(scene) {
            // 更新敌方冻结状态
            if (gameState.enemyFrozen && scene.time.now > gameState.enemyFreezeEndTime) {
                gameState.enemyFrozen = false;
            }
            
            // 更新玩家冻结状态
            if (gameState.playerFrozen && scene.time.now > gameState.playerFreezeEndTime) {
                gameState.playerFrozen = false;
            }
        }
        
        function checkBlackholes(scene) {
            blackholes.getChildren().forEach(blackhole => {
                // 检查玩家是否在黑洞范围内
                const distanceToPlayer = Phaser.Math.Distance.Between(
                    blackhole.x, blackhole.y,
                    playerCommander.x, playerCommander.y
                );
                
                // 黑洞引力范围（事件期间可能增强）
                const gravityRange = gameState.eventActive === 'blackholeConsume' ? 120 : 80;
                
                if (distanceToPlayer < gravityRange) {
                    // 被黑洞捕获
                    teleportToRandomLocation(scene, playerCommander);
                }
                
                // 检查敌方是否在黑洞范围内
                const distanceToEnemy = Phaser.Math.Distance.Between(
                    blackhole.x, blackhole.y,
                    enemyCommander.x, enemyCommander.y
                );
                
                if (distanceToEnemy < gravityRange) {
                    // 被黑洞捕获
                    teleportToRandomLocation(scene, enemyCommander);
                }
                
                // 检查克隆指挥官
                gameState.clonedCommanders.forEach(clone => {
                    const distanceToClone = Phaser.Math.Distance.Between(
                        blackhole.x, blackhole.y,
                        clone.commander.x, clone.commander.y
                    );
                    
                    if (distanceToClone < gravityRange) {
                        teleportToRandomLocation(scene, clone.commander);
                    }
                });
            });
        }
        
        function teleportToRandomLocation(scene, commander) {
            // 黑洞捕获效果
            createBlackholeCaptureEffect(scene, commander.x, commander.y);
            
            // 传送到随机位置（避免基地附近）
            let newX, newY;
            let validPosition = false;
            let attempts = 0;
            
            while (!validPosition && attempts < 20) {
                newX = Phaser.Math.Between(100, 1100);
                newY = Phaser.Math.Between(100, 600);
                
                const distToPlayerBase = Phaser.Math.Distance.Between(newX, newY, playerBase.x, playerBase.y);
                const distToEnemyBase = Phaser.Math.Distance.Between(newX, newY, enemyBase.x, enemyBase.y);
                
                if (distToPlayerBase > 150 && distToEnemyBase > 150) {
                    validPosition = true;
                }
                
                attempts++;
            }
            
            commander.x = newX;
            commander.y = newY;
            
            // 到达效果
            createArrivalEffect(scene, commander.x, commander.y);
        }
        
        function createBlackholeCaptureEffect(scene, x, y) {
            const captureEffect = scene.add.graphics();
            captureEffect.lineStyle(3, 0x9900ff, 0.8);
            captureEffect.strokeCircle(x, y, 35);
            
            scene.tweens.add({
                targets: captureEffect,
                scale: 0.5,
                alpha: 0,
                duration: 800,
                onComplete: () => captureEffect.destroy()
            });
            
            // 创建黑洞捕获粒子效果
            for (let i = 0; i < 15; i++) {
                const angle = Math.random() * Math.PI * 2;
                const distance = Math.random() * 60;
                const particle = scene.add.graphics();
                particle.fillStyle(0x9900ff, 1);
                particle.fillCircle(0, 0, 4);
                particle.x = x;
                particle.y = y;
                
                scene.tweens.add({
                    targets: particle,
                    x: x + Math.cos(angle) * distance,
                    y: y + Math.sin(angle) * distance,
                    alpha: 0,
                    duration: 800,
                    onComplete: () => particle.destroy()
                });
            }
        }
        
        function createArrivalEffect(scene, x, y) {
            const arriveEffect = scene.add.graphics();
            arriveEffect.lineStyle(4, 0xffffff, 0.8);
            arriveEffect.strokeCircle(x, y, 40);
            
            scene.tweens.add({
                targets: arriveEffect,
                scale: 1.5,
                alpha: 0,
                duration: 600,
                onComplete: () => arriveEffect.destroy()
            });
        }
        
        // AI决策算法
        function aiUpgrade(scene) {
            if (!gameState.gameActive) return;
            
            // AI根据当前情况决策
            const playerAdvantage = gameState.playerEnergy - gameState.enemyEnergy;
            const canUpgradeAttack = gameState.enemyEnergy >= 800;
            const canUpgradeDefense = gameState.enemyEnergy >= 1000;
            
            // 如果防御等级明显低于玩家
            if (gameState.enemyDefense < gameState.playerDefense - 2 && canUpgradeDefense) {
                // 优先升级防御
                gameState.enemyEnergy -= 1000;
                gameState.enemyDefense++;
                updateEnergyUI();
                createUpgradeEffect(scene, enemyBase.x, enemyBase.y, 0xff416c);
            } 
            // 如果攻击等级明显低于玩家
            else if (gameState.enemyAttack < gameState.playerAttack - 2 && canUpgradeAttack) {
                // 升级攻击
                gameState.enemyEnergy -= 800;
                gameState.enemyAttack++;
                updateEnergyUI();
                createUpgradeEffect(scene, enemyBase.x, enemyBase.y, 0xff0000);
            }
            // 如果能量优势较大
            else if (playerAdvantage < -2000 && canUpgradeAttack) {
                // 升级攻击
                gameState.enemyEnergy -= 800;
                gameState.enemyAttack++;
                updateEnergyUI();
                createUpgradeEffect(scene, enemyBase.x, enemyBase.y, 0xff0000);
            }
            // 如果能量劣势较大
            else if (playerAdvantage > 2000 && canUpgradeDefense) {
                // 升级防御
                gameState.enemyEnergy -= 1000;
                gameState.enemyDefense++;
                updateEnergyUI();
                createUpgradeEffect(scene, enemyBase.x, enemyBase.y, 0xff416c);
            }
            // 随机选择
            else {
                if (canUpgradeAttack && canUpgradeDefense) {
                    if (Math.random() > 0.5) {
                        gameState.enemyEnergy -= 800;
                        gameState.enemyAttack++;
                        updateEnergyUI();
                        createUpgradeEffect(scene, enemyBase.x, enemyBase.y, 0xff0000);
                    } else {
                        gameState.enemyEnergy -= 1000;
                        gameState.enemyDefense++;
                        updateEnergyUI();
                        createUpgradeEffect(scene, enemyBase.x, enemyBase.y, 0xff416c);
                    }
                } else if (canUpgradeAttack) {
                    gameState.enemyEnergy -= 800;
                    gameState.enemyAttack++;
                    updateEnergyUI();
                    createUpgradeEffect(scene, enemyBase.x, enemyBase.y, 0xff0000);
                } else if (canUpgradeDefense) {
                    gameState.enemyEnergy -= 1000;
                    gameState.enemyDefense++;
                    updateEnergyUI();
                    createUpgradeEffect(scene, enemyBase.x, enemyBase.y, 0xff416c);
                }
            }
        }

        // AI技能使用 - 修复所有技能
        function aiUseSkill(scene) {
            if (!gameState.gameActive) return;
            
            const aiSetting = difficultySettings[gameState.difficulty];
            if (Math.random() > aiSetting.aiSkillChance) return;
            
            // AI决策：根据情况选择技能
            const playerAdvantage = gameState.playerEnergy - gameState.enemyEnergy;
            const canUseFreeze = gameState.enemyEnergy >= 1000;
            const canUseNova = gameState.enemyEnergy >= 1500;
            const canUseClone = gameState.enemyEnergy >= 1200 && gameState.enemyCloneCooldown <= 0;
            const canUseShield = gameState.enemyEnergy >= 700 && gameState.enemyShieldCooldown <= 0;
            
            // 如果玩家能量优势较大
            if (playerAdvantage > 3000) {
                if (canUseFreeze) {
                    // 使用冻结技能干扰玩家
                    gameState.enemyEnergy -= 1000;
                    updateEnergyUI();
                    
                    // 显示AI技能通知
                    showAISkillNotice('敌方使用了时间冻结！');
                    
                    // 冻结玩家指挥官
                    gameState.playerFrozen = true;
                    gameState.playerFreezeEndTime = scene.time.now + 5000;
                    createFreezeEffect(scene, playerCommander.x, playerCommander.y);
                } 
                else if (canUseClone) {
                    // 使用克隆技能
                    gameState.enemyEnergy -= 1200;
                    gameState.enemyCloneCooldown = 20;
                    updateEnergyUI();
                    
                    // 显示AI技能通知
                    showAISkillNotice('敌方使用了克隆指挥官！');
                    
                    // 创建克隆指挥官
                    const clone = scene.physics.add.sprite(
                        enemyBase.x + Phaser.Math.Between(-100, 100),
                        enemyBase.y + Phaser.Math.Between(-100, 100),
                        'clone-commander'
                    ).setTint(0xff0000).setScale(1.5);
                    clone.body.setCollideWorldBounds(true);
                    
                    // 添加到克隆列表
                    gameState.clonedCommanders.push({
                        commander: clone,
                        createdTime: scene.time.now,
                        duration: 15000,
                        isEnemy: true
                    });
                    
                    // 添加克隆特效
                    createCloneEffect(scene, clone.x, clone.y);
                }
            } 
            // 如果AI能量优势较大
            else if (playerAdvantage < -2000 && canUseNova) {
                // 使用能量新星
                gameState.enemyEnergy -= 1500;
                updateEnergyUI();
                
                // 显示AI技能通知
                showAISkillNotice('敌方使用了能量新星！');
                
                // 创建能量新星效果
                createNovaEffect(scene, enemyCommander.x, enemyCommander.y);
                
                // 对玩家基地造成冲击波伤害
                const distanceToPlayerBase = Phaser.Math.Distance.Between(
                    enemyCommander.x, enemyCommander.y,
                    playerBase.x, playerBase.y
                );
                
                const maxDamage = 2500;
                const minDamage = 500;
                const damage = Math.max(minDamage, maxDamage - (distanceToPlayerBase / 5));
                
                gameState.playerEnergy = Math.max(0, gameState.playerEnergy - damage);
                updateEnergyUI();
                showDamage(scene, playerBase.x, playerBase.y - 50, damage);
                createShockwave(scene, enemyCommander.x, enemyCommander.y, playerBase.x, playerBase.y);
            }
            // 如果防御较低
            else if (gameState.enemyDefense < gameState.playerAttack && canUseShield) {
                // 使用护盾
                gameState.enemyEnergy -= 700;
                gameState.enemyShieldCooldown = 15;
                updateEnergyUI();
                
                // 显示AI技能通知
                showAISkillNotice('敌方使用了基地护盾！');
                
                // 激活基地护盾
                createEnemyShieldEffect(scene, enemyBase.x, enemyBase.y);
            }
            // 随机使用技能
            else {
                if (canUseFreeze && Math.random() > 0.5) {
                    gameState.enemyEnergy -= 1000;
                    updateEnergyUI();
                    showAISkillNotice('敌方使用了时间冻结！');
                    gameState.playerFrozen = true;
                    gameState.playerFreezeEndTime = scene.time.now + 5000;
                    createFreezeEffect(scene, playerCommander.x, playerCommander.y);
                } 
                else if (canUseClone) {
                    gameState.enemyEnergy -= 1200;
                    gameState.enemyCloneCooldown = 20;
                    updateEnergyUI();
                    showAISkillNotice('敌方使用了克隆指挥官！');
                    
                    const clone = scene.physics.add.sprite(
                        enemyBase.x + Phaser.Math.Between(-100, 100),
                        enemyBase.y + Phaser.Math.Between(-100, 100),
                        'clone-commander'
                    ).setTint(0xff0000).setScale(1.5);
                    clone.body.setCollideWorldBounds(true);
                    
                    gameState.clonedCommanders.push({
                        commander: clone,
                        createdTime: scene.time.now,
                        duration: 15000,
                        isEnemy: true
                    });
                    
                    createCloneEffect(scene, clone.x, clone.y);
                }
                else if (canUseShield) {
                    gameState.enemyEnergy -= 700;
                    gameState.enemyShieldCooldown = 15;
                    updateEnergyUI();
                    showAISkillNotice('敌方使用了基地护盾！');
                    createEnemyShieldEffect(scene, enemyBase.x, enemyBase.y);
                }
                else if (canUseNova) {
                    gameState.enemyEnergy -= 1500;
                    updateEnergyUI();
                    showAISkillNotice('敌方使用了能量新星！');
                    createNovaEffect(scene, enemyCommander.x, enemyCommander.y);
                    
                    const distanceToPlayerBase = Phaser.Math.Distance.Between(
                        enemyCommander.x, enemyCommander.y,
                        playerBase.x, playerBase.y
                    );
                    
                    const maxDamage = 2500;
                    const minDamage = 500;
                    const damage = Math.max(minDamage, maxDamage - (distanceToPlayerBase / 5));
                    
                    gameState.playerEnergy = Math.max(0, gameState.playerEnergy - damage);
                    updateEnergyUI();
                    showDamage(scene, playerBase.x, playerBase.y - 50, damage);
                    createShockwave(scene, enemyCommander.x, enemyCommander.y, playerBase.x, playerBase.y);
                }
            }
        }
        
        function createEnemyShieldEffect(scene, x, y) {
            // 创建护盾环 - 使用CSS动画
            const shieldRing = document.createElement('div');
            shieldRing.className = 'shield-ring';
            shieldRing.style.width = '130px';
            shieldRing.style.height = '130px';
            shieldRing.style.left = `${x - 65}px`;
            shieldRing.style.top = `${y - 65}px`;
            shieldRing.style.borderColor = '#ff416c';
            shieldRing.style.boxShadow = '0 0 15px rgba(255, 65, 108, 0.7)';
            
            document.getElementById('game-canvas').parentElement.appendChild(shieldRing);
            
            // 5秒后销毁护盾
            scene.time.delayedCall(5000, () => {
                if (shieldRing) {
                    shieldRing.remove();
                }
            });
        }

        function showAISkillNotice(message) {
            aiSkillNotice.textContent = message;
            aiSkillNotice.style.display = 'block';
            
            // 3秒后隐藏通知
            setTimeout(() => {
                aiSkillNotice.style.display = 'none';
            }, 3000);
        }
        
        function endGame(title, message) {
            gameState.gameActive = false;
            
            document.getElementById('message-title').textContent = title;
            document.getElementById('message-content').textContent = message;
            document.getElementById('message').style.display = 'block';
        }
        
        function restartGame() {
            location.reload();
        }
    </script>
</body>
</html>
