<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>基地能量争夺战 - 优化版</title>
    <script src="./phaser.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;500;700;900&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            user-select: none;
            touch-action: manipulation;
        }
        
        body {
            font-family: 'Orbitron', 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #0c1a3a, #1d2b5c);
            color: #fff;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            padding: 10px;
            touch-action: none;
        }
        
        /* 加载界面 */
        .loading-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #0c1a3a, #1d2b5c);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            transition: opacity 0.5s;
        }
        
        .loading-title {
            font-size: 2.5rem;
            margin-bottom: 30px;
            background: linear-gradient(90deg, #4dccff, #00ff9d);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-shadow: 0 0 12px rgba(77, 204, 255, 0.5);
            letter-spacing: 1px;
            font-weight: 700;
            text-align: center;
            padding: 0 20px;
        }
        
        .loading-subtitle {
            font-size: 1.2rem;
            margin-bottom: 40px;
            color: #aaccff;
            max-width: 90%;
            line-height: 1.4;
            text-shadow: 0 0 5px rgba(77, 204, 255, 0.3);
            text-align: center;
        }
        
        .progress-container {
            width: 80%;
            max-width: 400px;
            height: 20px;
            background: #112244;
            border-radius: 10px;
            overflow: hidden;
            position: relative;
            border: 2px solid #334477;
            box-shadow: inset 0 0 6px rgba(0, 0, 0, 0.5);
        }
        
        .progress-bar {
            height: 100%;
            background: linear-gradient(to right, #00c6ff, #0072ff);
            border-radius: 8px;
            width: 0;
            transition: width 0.3s ease;
        }
        
        .loading-stats {
            margin-top: 30px;
            font-size: 1rem;
            color: #4dccff;
            text-align: center;
        }
        
        /* 游戏容器 */
        .container {
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 100%;
            max-width: 100%;
            gap: 10px;
            position: relative;
            height: 100vh;
            display: none; /* 初始隐藏 */
        }
        
        .header-section {
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 100%;
            text-align: center;
            position: relative;
            padding: 5px 0;
            z-index: 100;
            background: rgba(0, 10, 30, 0.8);
            border-radius: 15px;
            margin-bottom: 5px;
            padding: 10px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.5);
            border: 1px solid #4dccff;
            max-height: 40vh;
            overflow-y: auto;
        }
        
        .title {
            font-size: 1.8rem;
            margin-bottom: 5px;
            background: linear-gradient(90deg, #4dccff, #00ff9d);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-shadow: 0 0 12px rgba(77, 204, 255, 0.5);
            letter-spacing: 1px;
            position: relative;
            animation: titleGlow 2s infinite alternate;
            font-weight: 700;
        }
        
        @keyframes titleGlow {
            0% { text-shadow: 0 0 12px rgba(77, 204, 255, 0.3); }
            100% { text-shadow: 0 0 20px rgba(77, 204, 255, 0.8); }
        }
        
        .title::after {
            content: '';
            position: absolute;
            bottom: -5px;
            left: 50%;
            transform: translateX(-50%);
            width: 150px;
            height: 3px;
            background: linear-gradient(90deg, #4dccff, #00ff9d);
            border-radius: 2px;
        }
        
        .subtitle {
            font-size: 0.85rem;
            margin-bottom: 10px;
            color: #aaccff;
            max-width: 95%;
            line-height: 1.4;
            text-shadow: 0 0 5px rgba(77, 204, 255, 0.3);
        }
        
        .game-container {
            position: relative;
            width: 100%;
            height: calc(100vh - 250px);
            max-height: 70vh;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.7);
            border-radius: 12px;
            overflow: hidden;
            border: 3px solid #445588;
            background: linear-gradient(135deg, #0c1a3a, #0f1f45);
            flex: 1;
        }
        
        #game-canvas {
            width: 100%;
            height: 100%;
            border-radius: 12px;
        }
        
        .ui-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
        }
        
        .game-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 15px;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 0 0 12px 12px;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.4);
            width: 100%;
            border-bottom: 2px solid #445588;
            z-index: 10;
            backdrop-filter: blur(5px);
        }
        
        .player-info {
            display: flex;
            flex-direction: column;
            align-items: center;
            min-width: 100px;
        }
        
        .player-name {
            font-size: 0.9rem;
            font-weight: bold;
            margin-bottom: 5px;
            color: #4dccff;
            text-shadow: 0 0 8px rgba(77, 204, 255, 0.7);
        }
        
        .energy-bar {
            width: 100%;
            height: 18px;
            background: #112244;
            border-radius: 10px;
            overflow: hidden;
            position: relative;
            border: 2px solid #334477;
            box-shadow: inset 0 0 6px rgba(0, 0, 0, 0.5);
        }
        
        .energy-fill {
            height: 100%;
            background: linear-gradient(to right, #00c6ff, #0072ff);
            border-radius: 8px;
            width: 100%;
            transition: width 0.5s ease;
        }
        
        .enemy-energy-fill {
            background: linear-gradient(to right, #ff416c, #ff4b2b);
        }
        
        .energy-display {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 0.75rem;
            color: white;
            text-shadow: 0 0 4px rgba(0, 0, 0, 0.8);
        }
        
        .timer {
            background: rgba(0, 0, 0, 0.6);
            padding: 6px 12px;
            border-radius: 20px;
            font-size: 0.9rem;
            font-weight: bold;
            color: #4dccff;
            border: 2px solid #445588;
            z-index: 10;
            backdrop-filter: blur(3px);
            box-shadow: 0 0 8px rgba(77, 204, 255, 0.3);
        }
        
        .game-content {
            flex: 1;
            position: relative;
        }
        
        .instructions {
            position: relative;
            background: rgba(0, 0, 0, 0.7);
            padding: 8px;
            border-radius: 8px;
            max-width: 100%;
            font-size: 0.75rem;
            line-height: 1.3;
            border: 2px solid #445588;
            z-index: 5;
            backdrop-filter: blur(4px);
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
            margin-bottom: 10px;
        }
        
        .instructions h3 {
            color: #ffcc00;
            margin-bottom: 5px;
            text-align: center;
            font-size: 0.85rem;
        }
        
        .instructions ul {
            padding-left: 15px;
        }
        
        .instructions li {
            margin-bottom: 4px;
            font-size: 0.7rem;
        }
        
        .controls-container {
            position: relative;
            width: 100%;
            margin-top: 10px;
        }
        
        .controls-toggle {
            align-self: flex-start;
            background: linear-gradient(to bottom, #2a3a6a, #1a2a5a);
            color: #aaccff;
            padding: 6px 12px;
            border-radius: 18px;
            cursor: pointer;
            font-weight: bold;
            border: 2px solid #556699;
            transition: all 0.2s;
            font-size: 0.8rem;
            pointer-events: all;
            margin-bottom: 5px;
            display: flex;
            align-items: center;
            gap: 5px;
            width: 100%;
            justify-content: center;
        }
        
        .controls-toggle:hover {
            background: linear-gradient(to bottom, #3a4a7a, #2a3a6a);
        }
        
        .controls {
            display: flex;
            flex-direction: column;
            gap: 8px;
            padding: 10px;
            background: rgba(0, 0, 0, 0.6);
            border-radius: 12px;
            pointer-events: all;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.6);
            border: 2px solid #445588;
            backdrop-filter: blur(4px);
            transform: translateY(0);
            transition: transform 0.3s ease, opacity 0.3s ease;
        }
        
        .controls.hidden {
            transform: translateY(20px);
            opacity: 0;
            pointer-events: none;
            height: 0;
            padding: 0;
        }
        
        .control-row {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
            justify-content: center;
        }
        
        .control-btn {
            display: flex;
            align-items: center;
            background: linear-gradient(to bottom, #2a3a6a, #1a2a5a);
            padding: 8px 10px;
            border-radius: 10px;
            min-width: 140px;
            cursor: pointer;
            transition: all 0.2s;
            border: 2px solid #556699;
            box-shadow: 0 3px 6px rgba(0, 0, 0, 0.4);
            pointer-events: all;
            gap: 8px;
            position: relative;
            overflow: hidden;
        }
        
        .control-btn:hover {
            transform: translateY(-3px);
            background: linear-gradient(to bottom, #3a4a7a, #2a3a6a);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.5);
        }
        
        .control-btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }
        
        .control-btn.cooldown {
            position: relative;
        }
        
        .control-btn.cooldown::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.6);
            pointer-events: none;
        }
        
        .control-icon {
            font-size: 1.3rem;
            color: #4dccff;
            min-width: 24px;
            text-align: center;
        }
        
        .control-text {
            display: flex;
            flex-direction: column;
        }
        
        .control-name {
            font-size: 0.8rem;
            font-weight: bold;
            color: #aaccff;
        }
        
        .control-cost {
            font-size: 0.7rem;
            color: #ffd700;
            font-weight: bold;
        }
        
        .cooldown-indicator {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 0;
            background: rgba(255, 215, 0, 0.3);
            transition: height 0.1s linear;
        }
        
        .event-notice {
            position: absolute;
            top: 80px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.7);
            padding: 8px 20px;
            border-radius: 8px;
            font-size: 0.9rem;
            font-weight: bold;
            color: #ffcc00;
            text-align: center;
            z-index: 100;
            display: none;
            border: 2px solid #ffcc00;
            box-shadow: 0 0 15px rgba(255, 204, 0, 0.5);
            max-width: 90%;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            backdrop-filter: blur(4px);
            animation: pulse 1.5s infinite;
        }
        
        @keyframes pulse {
            0% { transform: translateX(-50%) scale(1); }
            50% { transform: translateX(-50%) scale(1.05); }
            100% { transform: translateX(-50%) scale(1); }
        }
        
        .message {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            padding: 20px 30px;
            border-radius: 15px;
            text-align: center;
            z-index: 200;
            display: none;
            border: 3px solid #ffcc00;
            box-shadow: 0 0 30px rgba(255, 204, 0, 0.8);
            pointer-events: all;
            width: 85%;
            max-width: 400px;
            backdrop-filter: blur(10px);
        }
        
        .message h2 {
            color: #ffcc00;
            margin-bottom: 15px;
            font-size: 1.8rem;
            text-shadow: 0 0 10px rgba(255, 204, 0, 0.8);
        }
        
        .message p {
            font-size: 1.1rem;
            margin-bottom: 20px;
            line-height: 1.5;
            color: #eef;
        }
        
        .message button {
            background: linear-gradient(to right, #ff416c, #ff4b2b);
            border: none;
            color: white;
            padding: 10px 30px;
            border-radius: 30px;
            font-size: 1rem;
            cursor: pointer;
            transition: all 0.3s;
            font-weight: bold;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.4);
            margin-top: 10px;
        }
        
        .message button:hover {
            transform: scale(1.05);
            box-shadow: 0 6px 15px rgba(255, 75, 43, 0.6);
            background: linear-gradient(to right, #ff5577, #ff6a4b);
        }
        
        .stats {
            position: relative;
            background: rgba(0, 0, 0, 0.6);
            padding: 8px;
            border-radius: 8px;
            border: 2px solid #445588;
            z-index: 5;
            backdrop-filter: blur(4px);
            text-align: center;
            margin-bottom: 10px;
        }
        
        .stats h3 {
            color: #ffcc00;
            margin-bottom: 6px;
            font-size: 0.9rem;
        }
        
        .stat-item {
            display: flex;
            justify-content: space-between;
            margin-bottom: 4px;
            font-size: 0.75rem;
        }
        
        .stat-name {
            color: #aaccff;
        }
        
        .stat-value {
            color: #ffd700;
            font-weight: bold;
        }
        
        .sound-toggle {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.6);
            border: 2px solid #445588;
            border-radius: 50%;
            width: 32px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            z-index: 15;
            backdrop-filter: blur(4px);
        }
        
        .sound-toggle i {
            font-size: 1rem;
            color: #4dccff;
        }
        
        /* 收集特效 */
        .collect-ring {
            position: absolute;
            border-radius: 50%;
            pointer-events: none;
            z-index: 5;
            border: 2px solid #4dccff;
            box-shadow: 0 0 10px rgba(77, 204, 255, 0.8);
            animation: collectExpand 0.8s forwards;
        }
        
        @keyframes collectExpand {
            0% { transform: scale(0.5); opacity: 1; }
            100% { transform: scale(3); opacity: 0; }
        }
        
        /* 新添加的护盾效果 */
        .shield-ring {
            position: absolute;
            border-radius: 50%;
            pointer-events: none;
            z-index: 5;
            border: 3px solid #00ff9d;
            box-shadow: 0 0 15px rgba(0, 255, 157, 0.7);
            animation: shieldPulse 2s infinite;
        }
        
        @keyframes shieldPulse {
            0% { opacity: 0.8; box-shadow: 0 0 15px rgba(0, 255, 157, 0.7); }
            50% { opacity: 1; box-shadow: 0 0 25px rgba(0, 255, 157, 1); }
            100% { opacity: 0.8; box-shadow: 0 0 15px rgba(0, 255, 157, 0.7); }
        }
        
        .event-notice {
            position: absolute;
            top: 80px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.7);
            padding: 8px 20px;
            border-radius: 8px;
            font-size: 0.9rem;
            font-weight: bold;
            color: #ffcc00;
            text-align: center;
            z-index: 100;
            display: none;
            border: 2px solid #ffcc00;
            box-shadow: 0 0 15px rgba(255, 204, 0, 0.5);
            max-width: 90%;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            backdrop-filter: blur(4px);
            animation: pulse 1.5s infinite;
        }
        
        /* 能量收集提示 */
        .energy-popup {
            position: absolute;
            color: #4dccff;
            font-weight: bold;
            font-size: 1rem;
            text-shadow: 0 0 5px rgba(255,255,255,0.8);
            z-index: 20;
            pointer-events: none;
            animation: floatUp 1.2s forwards ease-out;
            text-align: center;
            width: 100px;
            margin-left: -50px;
        }
        
        @keyframes floatUp {
            0% { 
                transform: translateY(0); 
                opacity: 1;
                text-shadow: 0 0 5px currentColor;
            }
            70% {
                opacity: 0.9;
                text-shadow: 0 0 8px currentColor;
            }
            100% { 
                transform: translateY(-70px); 
                opacity: 0;
                text-shadow: 0 0 2px currentColor;
            }
        }
        
        /* 黑洞光环 */
        .blackhole-glow {
            position: absolute;
            border-radius: 50%;
            pointer-events: none;
            z-index: 4;
            border: 3px solid #9900ff;
            box-shadow: 0 0 25px rgba(153, 0, 255, 0.9);
            animation: blackholePulse 3s infinite;
        }
        
        @keyframes blackholePulse {
            0% { transform: scale(0.95); opacity: 0.8; box-shadow: 0 0 30px rgba(153, 0, 255, 0.9); }
            50% { transform: scale(1.05); opacity: 1; box-shadow: 0 0 40px rgba(153, 0, 255, 1); }
            100% { transform: scale(0.95); opacity: 0.8; box-shadow: 0 0 30px rgba(153, 0, 255, 0.9); }
        }
        
        /* 核心光环 */
        .core-glow {
            position: absolute;
            border-radius: 50%;
            pointer-events: none;
            z-index: 4;
            animation: corePulse 2s infinite;
        }
        
        @keyframes corePulse {
            0% { box-shadow: 0 0 10px rgba(77, 204, 255, 0.7); }
            50% { box-shadow: 0 0 20px rgba(77, 204, 255, 1); }
            100% { box-shadow: 0 0 10px rgba(77, 204, 255, 0.7); }
        }
        
        /* 响应式设计 */
        @media (max-width: 768px) {
            .game-container {
                height: calc(100vh - 280px);
                max-height: 60vh;
            }
            
            .title {
                font-size: 1.5rem;
            }
            
            .subtitle {
                font-size: 0.8rem;
            }
            
            .controls {
                bottom: 10px;
                left: 10px;
                right: 10px;
                max-width: 100%;
                transform: none;
                flex-direction: row;
                flex-wrap: wrap;
                justify-content: center;
                padding: 8px;
            }
            
            .control-btn {
                min-width: calc(50% - 10px);
                padding: 6px 8px;
                gap: 6px;
            }
            
            .control-icon {
                font-size: 1.1rem;
            }
            
            .control-name {
                font-size: 0.75rem;
            }
            
            .control-cost {
                font-size: 0.65rem;
            }
            
            .instructions {
                max-width: 160px;
                font-size: 0.7rem;
                padding: 6px;
            }
            
            .instructions li {
                font-size: 0.65rem;
            }
            
            .player-name {
                font-size: 0.8rem;
            }
            
            .energy-bar {
                height: 16px;
            }
            
            .energy-display {
                font-size: 0.7rem;
            }
            
            .timer {
                font-size: 0.8rem;
                padding: 5px 10px;
            }
            
            .event-notice {
                top: 70px;
                font-size: 0.8rem;
                padding: 6px 15px;
            }
            
            .stats {
                top: 8px;
                right: 8px;
                padding: 6px;
            }
            
            .stats h3 {
                font-size: 0.8rem;
            }
            
            .stat-item {
                font-size: 0.7rem;
            }
        }
        
        @media (max-width: 480px) {
            .game-container {
                height: calc(100vh - 300px);
            }
            
            .title {
                font-size: 1.3rem;
            }
            
            .subtitle {
                font-size: 0.75rem;
            }
            
            .control-btn {
                min-width: 100%;
            }
            
            .instructions {
                display: none;
            }
        }
        
        /* 横屏优化 - 重点改进 */
        @media (orientation: landscape) {
            .container {
                flex-direction: row;
                padding: 10px;
                height: 100vh;
                gap: 15px;
            }
            
            .header-section {
                width: 250px;
                height: calc(100% - 20px);
                margin-bottom: 0;
                padding: 15px 10px;
                justify-content: flex-start;
                overflow-y: auto;
                max-height: none;
            }
            
            .title {
                font-size: 1.3rem;
                margin-bottom: 10px;
            }
            
            .subtitle {
                font-size: 0.75rem;
                margin-bottom: 20px;
            }
            
            .game-container {
                height: calc(100vh - 20px);
                max-height: none;
                width: calc(100% - 280px);
            }
            
            .instructions {
                position: relative;
                top: 0;
                left: 0;
                max-width: 100%;
                font-size: 0.7rem;
                padding: 8px;
                margin-top: 10px;
            }
            
            .instructions h3 {
                font-size: 0.8rem;
            }
            
            .instructions li {
                font-size: 0.65rem;
            }
            
            .stats {
                position: relative;
                top: 0;
                right: 0;
                padding: 8px;
                margin-bottom: 10px;
            }
            
            .controls-container {
                position: relative;
                bottom: auto;
                left: auto;
                margin-top: 20px;
                width: 100%;
            }
            
            .controls {
                padding: 8px;
                transform: none;
            }
            
            .control-btn {
                min-width: 130px;
                padding: 6px 8px;
            }
            
            .control-icon {
                font-size: 1.1rem;
            }
            
            .control-name {
                font-size: 0.75rem;
            }
            
            .control-cost {
                font-size: 0.65rem;
            }
            
            .sound-toggle {
                top: 15px;
                right: 15px;
            }
            
            .game-header {
                padding: 8px 12px;
            }
            
            .player-name {
                font-size: 0.8rem;
            }
            
            .energy-bar {
                height: 16px;
            }
            
            .energy-display {
                font-size: 0.7rem;
            }
            
            .timer {
                font-size: 0.8rem;
                padding: 5px 10px;
            }
        }
        
        @media (orientation: landscape) and (max-height: 500px) {
            .header-section {
                padding: 5px;
                height: calc(100vh - 10px);
                width: 220px;
            }
            
            .title {
                font-size: 1.1rem;
                margin-bottom: 5px;
            }
            
            .subtitle {
                font-size: 0.7rem;
                margin-bottom: 10px;
            }
            
            .instructions {
                max-width: 100%;
                font-size: 0.65rem;
                top: 0;
            }
            
            .stats {
                top: 0;
                padding: 6px;
            }
        }
        
        /* 黑洞捕获效果 */
        .blackhole-capture {
            position: absolute;
            border-radius: 50%;
            pointer-events: none;
            z-index: 5;
            border: 3px solid #9900ff;
            box-shadow: 0 0 15px rgba(153, 0, 255, 0.7);
            animation: captureEffect 0.8s forwards;
        }
        
        @keyframes captureEffect {
            0% { transform: scale(0.5); opacity: 1; }
            100% { transform: scale(3); opacity: 0; }
        }
        
        /* 传送到达效果 */
        .arrival-effect {
            position: absolute;
            border-radius: 50%;
            pointer-events: none;
            z-index: 5;
            border: 3px solid #ffffff;
            box-shadow: 0 0 20px rgba(255, 255, 255, 0.8);
            animation: arrivalExpand 0.6s forwards;
        }
        
        @keyframes arrivalExpand {
            0% { transform: scale(0.5); opacity: 1; }
            100% { transform: scale(3); opacity: 0; }
        }
        
        /* 方向提示 */
        .orientation-message {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            z-index: 1000;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            padding: 20px;
        }
        
        .orientation-message i {
            font-size: 4rem;
            margin-bottom: 20px;
            color: #4dccff;
            animation: rotateDevice 2s infinite;
        }
        
        .orientation-message h2 {
            font-size: 1.8rem;
            color: #4dccff;
            margin-bottom: 15px;
        }
        
        .orientation-message p {
            font-size: 1.2rem;
            max-width: 80%;
            color: #ccc;
            line-height: 1.5;
        }
        
        @keyframes rotateDevice {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(90deg); }
        }
        
        @media (orientation: portrait) {
            .orientation-message {
                display: flex;
            }
        }
        
        /* 攻击特效 */
        .attack-beam {
            position: absolute;
            background: linear-gradient(to right, #00c6ff, #0072ff);
            height: 5px;
            border-radius: 3px;
            box-shadow: 0 0 10px rgba(0, 198, 255, 0.8);
            transform-origin: left center;
            animation: beamFade 0.5s forwards;
            z-index: 4;
        }
        
        @keyframes beamFade {
            0% { opacity: 1; }
            100% { opacity: 0; }
        }
        
        .enemy-attack-beam {
            background: linear-gradient(to right, #ff416c, #ff4b2b);
            box-shadow: 0 0 10px rgba(255, 65, 108, 0.8);
        }
        
        /* 冻结特效 */
        .freeze-effect {
            position: absolute;
            border-radius: 50%;
            pointer-events: none;
            z-index: 5;
            border: 3px solid #00ccff;
            box-shadow: 0 0 20px rgba(0, 204, 255, 0.8);
            animation: freezePulse 1.5s infinite;
        }
        
        @keyframes freezePulse {
            0% { transform: scale(0.8); opacity: 0.8; }
            50% { transform: scale(1.1); opacity: 1; }
            100% { transform: scale(0.8); opacity: 0.8; }
        }
        
        /* 新星爆炸特效 */
        .nova-explosion {
            position: absolute;
            border-radius: 50%;
            pointer-events: none;
            z-index: 6;
            background: radial-gradient(circle, #ffd700, #ff7700, transparent);
            animation: novaExpand 0.8s forwards;
        }
        
        @keyframes novaExpand {
            0% { transform: scale(0.1); opacity: 1; }
            100% { transform: scale(3); opacity: 0; }
        }
        
        /* 小行星 */
        .asteroid {
            position: absolute;
            border-radius: 50%;
            background: #8a7f7f;
            box-shadow: inset -5px -5px 10px rgba(0,0,0,0.5);
            z-index: 2;
        }
        
        /* 星云 */
        .nebula {
            position: absolute;
            border-radius: 50%;
            background: radial-gradient(circle, rgba(77, 204, 255, 0.2), transparent);
            z-index: 1;
            opacity: 0.4;
        }
    </style>
</head>
<body>
    <div class="loading-screen">
        <div class="loading-title">基地能量争夺战</div>
        <div class="loading-subtitle">正在加载游戏资源，请稍候...</div>
        <div class="progress-container">
            <div class="progress-bar" id="progress-bar"></div>
        </div>
        <div class="loading-stats" id="loading-stats">加载中: 0%</div>
    </div>
    
    <div class="orientation-message">
        <i class="fas fa-sync-alt"></i>
        <h2>请横屏游戏</h2>
        <p>为了获得最佳游戏体验，请将设备旋转至横屏模式</p>
    </div>
    
    <div class="container">
        <div class="header-section">
            <h1 class="title">基地能量争夺战</h1>
            <div class="subtitle">控制能量核心，升级基地，摧毁敌方基地！手机优化版</div>
            
            <div class="instructions">
                <h3>游戏说明</h3>
                <ul>
                    <li>指挥官自动收集能量核心</li>
                    <li>蓝核: +100 能量</li>
                    <li>金核: +500 能量</li>
                    <li>红核: +1000 能量</li>
                    <li>黑洞: 随机传送位置</li>
                    <li>使用能量升级基地或发动技能</li>
                    <li>摧毁敌方基地获得胜利</li>
                </ul>
            </div>
            
            <div class="stats">
                <h3>基地状态</h3>
                <div class="stat-item">
                    <span class="stat-name">攻击等级:</span>
                    <span class="stat-value" id="player-attack">1</span>
                </div>
                <div class="stat-item">
                    <span class="stat-name">防御等级:</span>
                    <span class="stat-value" id="player-defense">1</span>
                </div>
                <div class="stat-item">
                    <span class="stat-name">指挥官等级:</span>
                    <span class="stat-value" id="commander-level">1</span>
                </div>
            </div>
            
            <div class="controls-container">
                <div class="controls-toggle" id="controls-toggle">
                    <i class="fas fa-chevron-down"></i> 技能面板
                </div>
                <div class="controls" id="controls">
                    <div class="control-row">
                        <div class="control-btn" id="upgrade-defense">
                            <div class="control-icon"><i class="fas fa-shield-alt"></i></div>
                            <div class="control-text">
                                <div class="control-name">升级防御</div>
                                <div class="control-cost">消耗: 1,000能量</div>
                            </div>
                        </div>
                        
                        <div class="control-btn" id="upgrade-attack">
                            <div class="control-icon"><i class="fas fa-bolt"></i></div>
                            <div class="control-text">
                                <div class="control-name">升级攻击</div>
                                <div class="control-cost">消耗: 800能量</div>
                            </div>
                        </div>
                    </div>
                    
                    <div class="control-row">
                        <div class="control-btn" id="use-clone">
                            <div class="control-icon"><i class="fas fa-clone"></i></div>
                            <div class="control-text">
                                <div class="control-name">克隆指挥官</div>
                                <div class="control-cost">消耗: 1,200能量</div>
                            </div>
                            <div class="cooldown-indicator" id="clone-cooldown"></div>
                        </div>
                        
                        <div class="control-btn" id="use-shield">
                            <div class="control-icon"><i class="fas fa-shield-virus"></i></div>
                            <div class="control-text">
                                <div class="control-name">基地护盾</div>
                                <div class="control-cost">消耗: 700能量</div>
                            </div>
                            <div class="cooldown-indicator" id="shield-cooldown"></div>
                        </div>
                    </div>
                    
                    <div class="control-row">
                        <div class="control-btn" id="use-nova">
                            <div class="control-icon"><i class="fas fa-radiation"></i></div>
                            <div class="control-text">
                                <div class="control-name">能量新星</div>
                                <div class="control-cost">消耗: 1,500能量</div>
                            </div>
                            <div class="cooldown-indicator" id="nova-cooldown"></div>
                        </div>
                        
                        <div class="control-btn" id="use-freeze">
                            <div class="control-icon"><i class="fas fa-snowflake"></i></div>
                            <div class="control-text">
                                <div class="control-name">时间冻结</div>
                                <div class="control-cost">消耗: 1,000能量</div>
                            </div>
                            <div class="cooldown-indicator" id="freeze-cooldown"></div>
                        </div>
                    </div>
                    
                    <div class="control-row">
                        <div class="control-btn" id="upgrade-commander">
                            <div class="control-icon"><i class="fas fa-user-astronaut"></i></div>
                            <div class="control-text">
                                <div class="control-name">升级指挥官</div>
                                <div class="control-cost">消耗: 1,500能量</div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="game-container">
            <div id="game-canvas"></div>
            
            <div class="ui-overlay">
                <div class="sound-toggle" id="sound-toggle">
                    <i class="fas fa-volume-up"></i>
                </div>
                
                <div class="game-header">
                    <div class="player-info">
                        <div class="player-name">玩家基地</div>
                        <div class="energy-bar">
                            <div class="energy-fill" id="player-energy" style="width: 100%"></div>
                            <div class="energy-display">能量: <span id="player-energy-value">10,000</span></div>
                        </div>
                    </div>
                    
                    <div class="timer">时间: <span id="timer">00:00</span></div>
                    
                    <div class="player-info">
                        <div class="player-name">敌方基地</div>
                        <div class="energy-bar">
                            <div class="energy-fill enemy-energy-fill" id="enemy-energy" style="width: 100%"></div>
                            <div class="energy-display">能量: <span id="enemy-energy-value">10,000</span></div>
                        </div>
                    </div>
                </div>
                
                <div class="game-content">
                    <div class="event-notice" id="event-notice">能量风暴！所有核心产出翻倍</div>
                    <div class="ai-skill-notice" id="ai-skill-notice">敌方使用了瞬间传送！</div>
                    
                    <div class="message" id="message">
                        <h2 id="message-title">游戏结束</h2>
                        <p id="message-content">你的基地被摧毁了！</p>
                        <button id="restart-btn">重新开始</button>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- 移动端控制按钮 -->
        <div class="mobile-controls" id="mobile-controls" style="display: none;">
            <div class="mobile-btn" id="mobile-shield"><i class="fas fa-shield-alt"></i></div>
            <div class="mobile-btn" id="mobile-attack"><i class="fas fa-bolt"></i></div>
            <div class="mobile-btn" id="mobile-clone"><i class="fas fa-clone"></i></div>
            <div class="mobile-btn" id="mobile-freeze"><i class="fas fa-snowflake"></i></div>
        </div>
    </div>

    <script>
        // 资源预加载
        function preloadResources() {
            const totalResources = 8;
            let loaded = 0;
            
            const progressBar = document.getElementById('progress-bar');
            const loadingStats = document.getElementById('loading-stats');
            
            function updateProgress() {
                loaded++;
                const percent = Math.floor((loaded / totalResources) * 100);
                progressBar.style.width = `${percent}%`;
                loadingStats.textContent = `加载中: ${percent}%`;
                
                if (loaded === totalResources) {
                    setTimeout(() => {
                        document.querySelector('.loading-screen').style.opacity = '0';
                        setTimeout(() => {
                            document.querySelector('.loading-screen').style.display = 'none';
                            document.querySelector('.container').style.display = 'flex';
                        }, 500);
                    }, 500);
                }
            }
            
            // 模拟资源加载
            for (let i = 0; i < totalResources; i++) {
                setTimeout(updateProgress, 300 + i * 200);
            }
        }
        
        // 游戏配置
        const config = {
            type: Phaser.AUTO,
            width: 1200,
            height: 700,
            parent: 'game-canvas',
            scale: {
                mode: Phaser.Scale.FIT,
                autoCenter: Phaser.Scale.CENTER_BOTH
            },
            scene: {
                preload: preload,
                create: create,
                update: update
            },
            physics: {
                default: 'arcade',
                arcade: {
                    gravity: { y: 0 },
                    debug: false
                }
            },
            backgroundColor: '#0c1a3a'
        };

        // 游戏状态
        const gameState = {
            playerEnergy: 10000,
            enemyEnergy: 10000,
            gameActive: true,
            playerDefense: 1,
            enemyDefense: 1,
            playerAttack: 1,
            enemyAttack: 1,
            commanderLevel: 1,
            eventActive: null,
            eventEndTime: 0,
            gameTime: 0,
            cores: [],
            playerShieldActive: false,
            playerShieldEndTime: 0,
            cloneCooldown: 0,
            shieldCooldown: 0,
            novaCooldown: 0,
            freezeCooldown: 0,
            enemyFrozen: false,
            enemyFreezeEndTime: 0,
            playerFrozen: false,
            playerFreezeEndTime: 0,
            soundEnabled: true,
            clonedCommanders: [],
            isMobile: false,
            enemyCloneCooldown: 0,
            enemyShieldCooldown: 0,
            lastAttackTime: 0
        };

        // 创建游戏实例
        const game = new Phaser.Game(config);
        let playerBase, enemyBase, playerCommander, enemyCommander;
        let energyCores = [], blackholes = [];
        let playerEnergyBar, enemyEnergyBar, playerEnergyText, enemyEnergyText;
        let timerText, eventNotice, aiSkillNotice;
        let upgradeDefenseBtn, upgradeAttackBtn, cloneBtn, shieldBtn, novaBtn, freezeBtn, upgradeCommanderBtn;
        let cloneCooldownIndicator, shieldCooldownIndicator, novaCooldownIndicator, freezeCooldownIndicator;
        let playerAttackText, playerDefenseText, commanderLevelText;
        let soundToggle, controlsToggle, controlsPanel;
        let backgroundStars = [];
        let asteroids = [];

        // 修复后的坐标转换函数
        function worldToScreen(x, y) {
            const canvas = document.getElementById('game-canvas');
            if (!canvas) return { x: 0, y: 0 };
            
            const container = canvas.parentElement;
            if (!container) return { x: 0, y: 0 };
            
            // 获取画布在容器中的实际尺寸
            const canvasWidth = canvas.clientWidth;
            const canvasHeight = canvas.clientHeight;
            
            // 获取容器尺寸
            const containerWidth = container.clientWidth;
            const containerHeight = container.clientHeight;
            
            // 计算画布在容器中的偏移（居中）
            const leftOffset = (containerWidth - canvasWidth) / 2;
            const topOffset = (containerHeight - canvasHeight) / 2;
            
            // 计算游戏坐标到屏幕坐标的转换
            const scaleX = canvasWidth / config.width;
            const scaleY = canvasHeight / config.height;
            
            // 计算在容器内的位置
            const screenX = leftOffset + x * scaleX;
            const screenY = topOffset + y * scaleY;
            
            return { x: screenX, y: screenY };
        }

        function preload() {
            // 玩家基地
            this.load.image('player-base', 'data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="100" height="100" viewBox="0 0 100 100"><polygon points="50,10 90,30 90,70 50,90 10,70 10,30" fill="%234dccff" stroke="%23007bff" stroke-width="5"/></svg>');
            
            // 敌方基地
            this.load.image('enemy-base', 'data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="100" height="100" viewBox="0 0 100 100"><polygon points="50,10 90,30 90,70 50,90 10,70 10,30" fill="%23ff416c" stroke="%23ff0000" stroke-width="5"/></svg>');
            
            // 玩家指挥官
            this.load.image('player-commander', 'data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="50" height="50" viewBox="0 0 50 50"><rect x="15" y="15" width="20" height="20" rx="5" fill="%234dccff"/><rect x="20" y="35" width="10" height="10" fill="%234dccff"/></svg>');

            // 敌方指挥官
            this.load.image('enemy-commander', 'data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="50" height="50" viewBox="0 0 50 50"><rect x="15" y="15" width="20" height="20" rx="5" fill="%23ff0000"/><rect x="20" y="35" width="10" height="10" fill="%23ff0000"/></svg>');
            
            // 克隆指挥官
            this.load.image('clone-commander', 'data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="50" height="50" viewBox="0 0 50 50"><rect x="15" y="15" width="20" height="20" rx="5" fill="%2300cc66"/><rect x="20" y="35" width="10" height="10" fill="%2300cc66"/></svg>');
            
            // 能量核心
            this.load.image('core-blue', 'data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="40" height="40" viewBox="0 0 40 40"><circle cx="20" cy="20" r="18" fill="%230072ff"/><circle cx="20" cy="20" r="12" fill="%234dccff"/></svg>');
            this.load.image('core-gold', 'data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="40" height="40" viewBox="0 0 40 40"><circle cx="20" cy="20" r="18" fill="%23ffd700"/><circle cx="20" cy="20" r="12" fill="%23ffff00"/></svg>');
            this.load.image('core-red', 'data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="40" height="40" viewBox="0 0 40 40"><circle cx="20" cy="20" r="18" fill="%23ff416c"/><circle cx="20" cy="20" r="12" fill="%23ff9999"/></svg>');
            
            // 黑洞 - 改进为更暗的版本
            this.load.image('blackhole', 'data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="60" height="60" viewBox="0 0 60 60"><circle cx="30" cy="30" r="28" fill="%23000"/><circle cx="30" cy="30" r="24" fill="%23111111"/><circle cx="30" cy="30" r="20" fill="%23222"/><circle cx="30" cy="30" r="16" fill="%23333"/><circle cx="30" cy="30" r="12" fill="%23444"/></svg>');
            
            // 星星
            this.load.image('star', 'data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="10" height="10" viewBox="0 0 10 10"><circle cx="5" cy="5" r="2" fill="%23ffffff"/></svg>');
            
            // 冻结效果
            this.load.image('frost', 'data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="60" height="60" viewBox="0 0 60 60"><circle cx="30" cy="30" r="25" fill="%2300ccff" opacity="0.3"/></svg>');
        }

        function create() {
            // 检测移动设备
            gameState.isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
         
            // 技能面板控制
            controlsToggle = document.getElementById('controls-toggle');
            controlsPanel = document.getElementById('controls');
            controlsToggle.addEventListener('touchstart', () => {
                controlsPanel.classList.toggle('hidden');
                const icon = controlsToggle.querySelector('i');
                icon.className = controlsPanel.classList.contains('hidden') ? 
                    'fas fa-chevron-up' : 'fas fa-chevron-down';
            });
            
            // 初始化游戏物理世界
            this.physics.world.setBounds(0, 0, 1200, 700);
            
            // 创建背景装饰
            createBackgroundDecorations(this);
            
            // 创建基地
            playerBase = this.physics.add.sprite(100, 550, 'player-base').setScale(1.2).setTint(0x4dccff);
            playerBase.body.setImmovable(true);
            playerBase.setDepth(1);
            
            enemyBase = this.physics.add.sprite(1150, 150, 'enemy-base').setScale(1.2).setTint(0xff416c);
            enemyBase.body.setImmovable(true);
            enemyBase.setDepth(1);
            
            // 创建指挥官
            playerCommander = this.physics.add.sprite(200, 450, 'player-commander').setScale(1.5);
            playerCommander.body.setCollideWorldBounds(true);
            playerCommander.setDepth(2);
            
            enemyCommander = this.physics.add.sprite(1000, 300, 'enemy-commander').setScale(1.5);
            enemyCommander.body.setCollideWorldBounds(true);
            enemyCommander.setDepth(2);
            
            // 创建能量核心
            createEnergyCores(this);
            
            // 创建黑洞
            createBlackholes(this);
            
            // 创建小行星带
            createAsteroidField(this);
            
            // 初始化UI元素
            playerEnergyBar = document.getElementById('player-energy');
            enemyEnergyBar = document.getElementById('enemy-energy');
            playerEnergyText = document.getElementById('player-energy-value');
            enemyEnergyText = document.getElementById('enemy-energy-value');
            timerText = document.getElementById('timer');
            eventNotice = document.getElementById('event-notice');
            aiSkillNotice = document.getElementById('ai-skill-notice');
            playerAttackText = document.getElementById('player-attack');
            playerDefenseText = document.getElementById('player-defense');
            commanderLevelText = document.getElementById('commander-level');
            
            // 添加事件监听
            upgradeDefenseBtn = document.getElementById('upgrade-defense');
            upgradeAttackBtn = document.getElementById('upgrade-attack');
            cloneBtn = document.getElementById('use-clone');
            shieldBtn = document.getElementById('use-shield');
            novaBtn = document.getElementById('use-nova');
            freezeBtn = document.getElementById('use-freeze');
            upgradeCommanderBtn = document.getElementById('upgrade-commander');
            
            cloneCooldownIndicator = document.getElementById('clone-cooldown');
            shieldCooldownIndicator = document.getElementById('shield-cooldown');
            novaCooldownIndicator = document.getElementById('nova-cooldown');
            freezeCooldownIndicator = document.getElementById('freeze-cooldown');
            
            upgradeDefenseBtn.addEventListener('touchstart', () => upgradeDefense(this));
            upgradeAttackBtn.addEventListener('touchstart', () => upgradeAttack(this));
            cloneBtn.addEventListener('touchstart', () => useClone(this));
            shieldBtn.addEventListener('touchstart', () => useShield(this));
            novaBtn.addEventListener('touchstart', () => useNova(this));
            freezeBtn.addEventListener('touchstart', () => useFreeze(this));
            upgradeCommanderBtn.addEventListener('touchstart', () => upgradeCommander(this));
            
            document.getElementById('restart-btn').addEventListener('touchstart', restartGame);
            
            // 设置游戏时钟
            this.time.addEvent({
                delay: 1000,
                callback: () => {
                    if (gameState.gameActive) {
                        gameState.gameTime++;
                        updateTimer();
                        
                        // 更新冷却时间
                        if (gameState.cloneCooldown > 0) {
                            gameState.cloneCooldown--;
                            cloneCooldownIndicator.style.height = `${100 - (gameState.cloneCooldown / 20) * 100}%`;
                        }
                        
                        if (gameState.shieldCooldown > 0) {
                            gameState.shieldCooldown--;
                            shieldCooldownIndicator.style.height = `${100 - (gameState.shieldCooldown / 15) * 100}%`;
                        }
                        
                        if (gameState.novaCooldown > 0) {
                            gameState.novaCooldown--;
                            novaCooldownIndicator.style.height = `${100 - (gameState.novaCooldown / 25) * 100}%`;
                        }
                        
                        if (gameState.freezeCooldown > 0) {
                            gameState.freezeCooldown--;
                            freezeCooldownIndicator.style.height = `${100 - (gameState.freezeCooldown / 30) * 100}%`;
                        }
                        
                        // 更新AI冷却时间
                        if (gameState.enemyCloneCooldown > 0) gameState.enemyCloneCooldown--;
                        if (gameState.enemyShieldCooldown > 0) gameState.enemyShieldCooldown--;
                        
                        // 更新克隆指挥官
                        updateClonedCommanders(this);
                    }
                },
                loop: true
            });
            
            // 设置随机事件定时器
            this.time.addEvent({
                delay: 15000,
                callback: () => triggerRandomEvent(this),
                loop: true
            });
            
            // 设置AI升级定时器
            this.time.addEvent({
                delay: 10000,
                callback: () => aiUpgrade(this),
                loop: true
            });
            
            // 设置AI技能使用定时器
            this.time.addEvent({
                delay: 6000,
                callback: () => aiUseSkill(this),
                loop: true
            });
        }

        function createBackgroundDecorations(scene) {
            // 创建星云背景
            for (let i = 0; i < 6; i++) {
                const nebula = document.createElement('div');
                nebula.className = 'nebula';
                const size = Phaser.Math.Between(150, 300);
                nebula.style.width = `${size}px`;
                nebula.style.height = `${size}px`;
                nebula.style.left = `${Phaser.Math.Between(0, 1200)}px`;
                nebula.style.top = `${Phaser.Math.Between(0, 700)}px`;
                nebula.style.opacity = Phaser.Math.FloatBetween(0.2, 0.4);
                nebula.style.backgroundColor = `rgba(${Phaser.Math.Between(50, 200)}, ${Phaser.Math.Between(100, 200)}, ${Phaser.Math.Between(150, 255)}, 0.2)`;
                document.getElementById('game-canvas').parentElement.appendChild(nebula);
                
                // 添加缓慢移动
                scene.tweens.add({
                    targets: nebula,
                    x: `+=${Phaser.Math.Between(-50, 50)}`,
                    y: `+=${Phaser.Math.Between(-50, 50)}`,
                    duration: Phaser.Math.Between(15000, 30000),
                    yoyo: true,
                    repeat: -1,
                    ease: 'Sine.easeInOut'
                });
            }
            
            // 创建星星
            for (let i = 0; i < 150; i++) {
                const star = scene.add.sprite(
                    Phaser.Math.Between(0, 1200),
                    Phaser.Math.Between(0, 700),
                    'star'
                );
                star.setAlpha(Phaser.Math.FloatBetween(0.3, 0.8));
                star.setScale(Phaser.Math.FloatBetween(0.5, 1.2));
                star.setDepth(0);
                backgroundStars.push(star);
                
                // 让星星闪烁
                scene.tweens.add({
                    targets: star,
                    alpha: Phaser.Math.FloatBetween(0.1, 0.5),
                    duration: Phaser.Math.Between(1000, 3000),
                    yoyo: true,
                    repeat: -1
                });
            }
        }
        
        function createAsteroidField(scene) {
            // 创建小行星带
            for (let i = 0; i < 20; i++) {
                const asteroid = document.createElement('div');
                asteroid.className = 'asteroid';
                const size = Phaser.Math.Between(10, 30);
                asteroid.style.width = `${size}px`;
                asteroid.style.height = `${size}px`;
                const x = Phaser.Math.Between(0, 1200);
                const y = Phaser.Math.Between(0, 700);
                asteroid.style.left = `${x}px`;
                asteroid.style.top = `${y}px`;
                asteroid.style.transform = `rotate(${Phaser.Math.Between(0, 360)}deg)`;
                document.getElementById('game-canvas').parentElement.appendChild(asteroid);
                asteroids.push({element: asteroid, x, y, size});
                
                // 添加小行星运动
                scene.tweens.add({
                    targets: asteroid,
                    left: `+=${Phaser.Math.Between(-100, 100)}`,
                    top: `+=${Phaser.Math.Between(-100, 100)}`,
                    duration: Phaser.Math.Between(10000, 20000),
                    yoyo: true,
                    repeat: -1,
                    ease: 'Sine.easeInOut'
                });
            }
        }

        function createEnergyCores(scene) {
            // 创建能量核心
            const corePositions = [];
            
            // 生成位置确保在屏幕内且不靠近基地
            for (let i = 0; i < 8; i++) {
                let validPosition = false;
                let x, y;
                
                while (!validPosition) {
                    x = Phaser.Math.Between(100, 1100);
                    y = Phaser.Math.Between(100, 600);
                    
                    // 检查是否靠近玩家基地
                    const distToPlayer = Phaser.Math.Distance.Between(x, y, playerBase.x, playerBase.y);
                    const distToEnemy = Phaser.Math.Distance.Between(x, y, enemyBase.x, enemyBase.y);
                    
                    // 如果位置有效
                    if (distToPlayer > 150 && distToEnemy > 150) {
                        validPosition = true;
                        corePositions.push({x, y});
                    }
                }
            }
            
            // 创建核心
            corePositions.forEach(pos => {
                const coreType = Phaser.Math.RND.pick(['blue', 'gold', 'red']);
                let core;
                
                switch(coreType) {
                    case 'blue':
                        core = scene.physics.add.sprite(pos.x, pos.y, 'core-blue');
                        core.energyValue = 100;
                        break;
                    case 'gold':
                        core = scene.physics.add.sprite(pos.x, pos.y, 'core-gold');
                        core.energyValue = 500;
                        break;
                    case 'red':
                        core = scene.physics.add.sprite(pos.x, pos.y, 'core-red');
                        core.energyValue = 1000;
                        break;
                }
                
                core.setScale(1.2);
                core.type = coreType;
                core.collected = false;
                core.collectTimer = 0;
                core.setDepth(3);
                
                // 添加核心旋转动画
                scene.tweens.add({
                    targets: core,
                    angle: 360,
                    duration: 5000 + Math.random() * 5000,
                    repeat: -1,
                    ease: 'Linear'
                });
                
                energyCores.push(core);
                gameState.cores.push(core);
            });
        }
        
        function createBlackholes(scene) {
            // 创建黑洞
            blackholes = scene.physics.add.staticGroup();
            
            const blackholePositions = [];
            
            // 生成位置确保在屏幕内且不靠近基地
            for (let i = 0; i < 2; i++) {
                let validPosition = false;
                let x, y;
                
                while (!validPosition) {
                    x = Phaser.Math.Between(200, 1000);
                    y = Phaser.Math.Between(100, 600);
                    
                    // 检查是否靠近玩家基地
                    const distToPlayer = Phaser.Math.Distance.Between(x, y, playerBase.x, playerBase.y);
                    const distToEnemy = Phaser.Math.Distance.Between(x, y, enemyBase.x, enemyBase.y);
                    
                    // 如果位置有效
                    if (distToPlayer > 200 && distToEnemy > 200) {
                        validPosition = true;
                        blackholePositions.push({x, y});
                    }
                }
            }
            
            // 创建黑洞
            blackholePositions.forEach(pos => {
                const blackhole = blackholes.create(pos.x, pos.y, 'blackhole');
                blackhole.setScale(0.8);
                blackhole.setDepth(3);
                
                // 添加黑洞引力范围提示
                const blackholeGlow = document.createElement('div');
                blackholeGlow.className = 'blackhole-glow';
                blackholeGlow.style.width = '100px';
                blackholeGlow.style.height = '100px';
                const posScreen = worldToScreen(pos.x, pos.y);
                blackholeGlow.style.left = `${posScreen.x - 50}px`;
                blackholeGlow.style.top = `${posScreen.y - 50}px`;
                document.getElementById('game-canvas').parentElement.appendChild(blackholeGlow);
                
                // 添加黑洞旋转动画
                scene.tweens.add({
                    targets: blackhole,
                    angle: 360,
                    duration: 8000,
                    repeat: -1,
                    ease: 'Linear'
                });
            });
        }
        
        function update() {
            if (!gameState.gameActive) return;
    
            // 更新玩家指挥官行为
            updateCommander(this, playerCommander, true);
            
            // 更新克隆指挥官行为
            updateClonedCommanders(this);
            
            // 更新敌方指挥官行为
            updateCommander(this, enemyCommander, false);
            
            // 检查基地攻击
            checkBaseAttacks(this);
            
            // 更新事件状态
            updateEventStatus(this);
            
            // 更新护盾状态
            updateShieldStatus(this);
            
            // 更新冻结状态
            updateFreezeStatus(this);
            
            // 检查黑洞效果
            checkBlackholes(this);
        }
        
        function updateCommander(scene, commander, isPlayer) {
            // 检查是否被冻结
            let isFrozen = false;
            if (isPlayer && gameState.playerFrozen) {
                isFrozen = true;
            } else if (!isPlayer && gameState.enemyFrozen) {
                isFrozen = true;
            }
            
            // 对于克隆指挥官，检查单独的冻结状态
            if (commander.isClone) {
                const cloneData = gameState.clonedCommanders.find(c => c.commander === commander);
                if (cloneData && cloneData.frozen) {
                    isFrozen = true;
                }
            }
            
            if (isFrozen) {
                commander.body.setVelocity(0);
                // 添加冰霜视觉效果
                if (!commander.frostEffect) {
                    commander.frostEffect = scene.add.sprite(commander.x, commander.y, 'frost');
                    commander.frostEffect.setScale(1.5);
                    commander.frostEffect.setDepth(3);
                }
                return;
            } else if (commander.frostEffect) {
                commander.frostEffect.destroy();
                commander.frostEffect = null;
            }
            
            // 寻找最近的可收集核心
            let nearestCore = null;
            let minDistance = Infinity;
            
            energyCores.forEach(core => {
                if (!core.collected) {
                    const distance = Phaser.Math.Distance.Between(
                        commander.x, commander.y, 
                        core.x, core.y
                    );
                    
                    if (distance < minDistance) {
                        minDistance = distance;
                        nearestCore = core;
                    }
                }
            });
            
            // 向最近的核心移动
            if (nearestCore) {
                scene.physics.moveToObject(commander, nearestCore, 150 * gameState.commanderLevel);
                
                // 检查是否到达核心
                if (minDistance < 40) {
                    // 收集核心
                    if (!nearestCore.collected) {
                        nearestCore.collected = true;
                        
                        // 增加能量
                        let energyValue = nearestCore.energyValue;
                        
                        // 事件影响
                        if (gameState.eventActive === 'energyStorm') {
                            energyValue *= 2;
                        } else if (gameState.eventActive === 'energyDrain') {
                            energyValue = Math.floor(energyValue * 0.5);
                        }
                        
                        if (isPlayer) {
                            gameState.playerEnergy += energyValue;
                        } else {
                            gameState.enemyEnergy += energyValue;
                        }
                        
                        // 更新UI
                        updateEnergyUI();
                        
                        // 显示收集效果
                        createCollectEffect(commander.x, commander.y, isPlayer);
                        
                        // 显示能量收集提示 - 修正位置在核心正上方
                        createEnergyPopup(nearestCore.x, nearestCore.y, energyValue, isPlayer);
                        
                        // 隐藏核心
                        nearestCore.setVisible(false);
                        
                        // 红色核心可能爆炸
                        if (nearestCore.type === 'red' && Phaser.Math.Between(1, 100) <= 30) {
                            // 对指挥官造成伤害
                            const damage = 1000;
                            if (isPlayer) {
                                gameState.playerEnergy = Math.max(0, gameState.playerEnergy - damage);
                            } else {
                                gameState.enemyEnergy = Math.max(0, gameState.enemyEnergy - damage);
                            }
                            
                            updateEnergyUI();
                        }
                        
                        // 重置核心（一段时间后）
                        scene.time.delayedCall(5000, () => {
                            if (gameState.gameActive) {
                                repositionCore(scene, nearestCore);
                            }
                        });
                    }
                }
            } else {
                // 没有核心时停止移动
                commander.body.setVelocity(0);
            }
        }
        
        function repositionCore(scene, core) {
            let validPosition = false;
            let newX, newY;
            
            while (!validPosition) {
                newX = Phaser.Math.Between(100, 1100);
                newY = Phaser.Math.Between(100, 600);
                
                // 检查是否靠近基地
                const distToPlayer = Phaser.Math.Distance.Between(newX, newY, playerBase.x, playerBase.y);
                const distToEnemy = Phaser.Math.Distance.Between(newX, newY, enemyBase.x, enemyBase.y);
                
                // 检查是否靠近其他核心
                let tooCloseToOther = false;
                energyCores.forEach(otherCore => {
                    if (otherCore !== core && !otherCore.collected) {
                        const dist = Phaser.Math.Distance.Between(newX, newY, otherCore.x, otherCore.y);
                        if (dist < 100) {
                            tooCloseToOther = true;
                        }
                    }
                });
                
                // 如果位置有效
                if (distToPlayer > 150 && distToEnemy > 150 && !tooCloseToOther) {
                    validPosition = true;
                    core.x = newX;
                    core.y = newY;
                    core.collected = false;
                    core.setVisible(true);
                }
            }
        }
        
        function createEnergyPopup(x, y, value, isPlayer) {
            const pos = worldToScreen(x, y);
            const popup = document.createElement('div');
            popup.className = 'energy-popup';
            popup.textContent = `+${value}`;
            popup.style.color = isPlayer ? '#4dccff' : '#ff416c';
            popup.style.left = `${pos.x}px`;
            popup.style.top = `${pos.y - 50}px`; // 在核心正上方显示
            document.getElementById('game-canvas').parentElement.appendChild(popup);
            
            // 1秒后移除
            setTimeout(() => {
                popup.remove();
            }, 1000);
        }
        
        function createCollectEffect(x, y, isPlayer) {
            const pos = worldToScreen(x, y);
            const color = isPlayer ? '#4dccff' : '#ff416c';
            const ring = document.createElement('div');
            ring.className = 'collect-ring';
            ring.style.left = `${pos.x - 25}px`;
            ring.style.top = `${pos.y - 25}px`;
            ring.style.borderColor = color;
            ring.style.boxShadow = `0 0 10px ${color}`;
            
            document.getElementById('game-canvas').parentElement.appendChild(ring);
            
            setTimeout(() => {
                ring.remove();
            }, 800);
        }
        
        function updateEnergyUI() {
            // 格式化数字显示
            const formatNumber = num => {
                if (num >= 1000000) return `${(num/1000000).toFixed(1)}M`;
                if (num >= 1000) return `${(num/1000).toFixed(1)}K`;
                return num.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ",");
            };
            
            // 更新玩家能量（最大1万）
            const playerPercent = Math.min(100, Math.max(0, (gameState.playerEnergy / 10000) * 100));
            playerEnergyBar.style.width = `${playerPercent}%`;
            playerEnergyText.textContent = formatNumber(gameState.playerEnergy);
            
            // 更新敌方能量（最大1万）
            const enemyPercent = Math.min(100, Math.max(0, (gameState.enemyEnergy / 10000) * 100));
            enemyEnergyBar.style.width = `${enemyPercent}%`;
            enemyEnergyText.textContent = formatNumber(gameState.enemyEnergy);
            
            // 更新状态显示
            playerAttackText.textContent = gameState.playerAttack;
            playerDefenseText.textContent = gameState.playerDefense;
            commanderLevelText.textContent = gameState.commanderLevel;
            
            // 检查游戏结束
            if (gameState.playerEnergy <= 0) {
                gameState.playerEnergy = 0;
                endGame('失败！', '你的基地能量耗尽！');
            }
            
            if (gameState.enemyEnergy <= 0) {
                gameState.enemyEnergy = 0;
                endGame('胜利！', '你成功摧毁了敌方基地！');
            }
        }
        
        function updateTimer() {
            const minutes = Math.floor(gameState.gameTime / 60);
            const seconds = gameState.gameTime % 60;
            timerText.textContent = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
        }
        
        function checkBaseAttacks(scene) {
            const now = scene.time.now;
            
            // 玩家基地攻击
            if (now - gameState.lastAttackTime > 2000 && gameState.playerAttack > 0) {
                gameState.lastAttackTime = now;
                
                // 考虑防御等级
                const damage = Math.floor(18 * gameState.playerAttack / gameState.enemyDefense);
                gameState.enemyEnergy = Math.max(0, gameState.enemyEnergy - damage);
                
                // 创建攻击光束特效 - 使用基地中心坐标
                createAttackBeam(playerBase.x, playerBase.y, enemyBase.x, enemyBase.y, true);
                
                updateEnergyUI();
            }
            
            // 敌方基地攻击
            if (now - gameState.lastAttackTime > 2000 && gameState.enemyAttack > 0) {
                gameState.lastAttackTime = now;
                
                // 考虑防御等级和护盾
                let damage = Math.floor(18 * gameState.enemyAttack / gameState.playerDefense);
                
                // 如果护盾激活，减免50%伤害
                if (gameState.playerShieldActive) {
                    damage = Math.floor(damage * 0.5);
                }
                
                gameState.playerEnergy = Math.max(0, gameState.playerEnergy - damage);
                
                // 创建攻击光束特效 - 使用基地中心坐标
                createAttackBeam(enemyBase.x, enemyBase.y, playerBase.x, playerBase.y, false);
                
                updateEnergyUI();
            }
        }
        
        function createAttackBeam(fromX, fromY, toX, toY, isPlayer) {
            const fromPos = worldToScreen(fromX, fromY);
            const toPos = worldToScreen(toX, toY);
            
            // 计算距离和角度
            const dx = toPos.x - fromPos.x;
            const dy = toPos.y - fromPos.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            const angle = Math.atan2(dy, dx) * (180 / Math.PI);
            
            const beam = document.createElement('div');
            beam.className = isPlayer ? 'attack-beam' : 'attack-beam enemy-attack-beam';
            beam.style.width = `${distance}px`;
            beam.style.left = `${fromPos.x}px`;
            beam.style.top = `${fromPos.y}px`;
            beam.style.transform = `rotate(${angle}deg)`;
            beam.style.transformOrigin = 'left center';
            
            document.getElementById('game-canvas').parentElement.appendChild(beam);
            
            setTimeout(() => {
                beam.remove();
            }, 500);
        }
        
        function upgradeDefense(scene) {
            if (gameState.playerEnergy < 1000) return;
            
            gameState.playerEnergy -= 1000;
            gameState.playerDefense++;
            updateEnergyUI();
            
            // 显示升级特效 - 完美环绕基地
            createUpgradeEffect(playerBase.x, playerBase.y, true);
        }
        
        function upgradeAttack(scene) {
            if (gameState.playerEnergy < 800) return;
            
            gameState.playerEnergy -= 800;
            gameState.playerAttack++;
            updateEnergyUI();
            
            // 显示升级特效 - 完美环绕基地
            createUpgradeEffect(playerBase.x, playerBase.y, false);
        }
        
        function upgradeCommander(scene) {
            if (gameState.playerEnergy < 1500) return;
            
            gameState.playerEnergy -= 1500;
            gameState.commanderLevel++;
            updateEnergyUI();
            
            // 显示升级特效
            createUpgradeEffect(playerCommander.x, playerCommander.y, true);
        }
        
        function createUpgradeEffect(x, y, isDefense) {
            const pos = worldToScreen(x, y);
            const color = isDefense ? '#4dccff' : '#ffd700';
            const effect = document.createElement('div');
            effect.className = 'shield-ring';
            effect.style.width = '100px';
            effect.style.height = '100px';
            effect.style.left = `${pos.x - 50}px`; // 居中显示
            effect.style.top = `${pos.y - 50}px`; // 居中显示
            effect.style.borderColor = color;
            effect.style.boxShadow = `0 0 15px ${color}`;
            
            document.getElementById('game-canvas').parentElement.appendChild(effect);
            
            setTimeout(() => {
                effect.remove();
            }, 2000);
        }
        
        function useClone(scene) {
            if (gameState.playerEnergy < 1200 || gameState.cloneCooldown > 0) return;
            
            gameState.playerEnergy -= 1200;
            gameState.cloneCooldown = 20;
            cloneCooldownIndicator.style.height = '100%';
            updateEnergyUI();
            
            // 创建克隆指挥官
            const clone = scene.physics.add.sprite(
                playerBase.x + Phaser.Math.Between(-100, 100),
                playerBase.y + Phaser.Math.Between(-100, 100),
                'clone-commander'
            ).setScale(1.5);
            clone.body.setCollideWorldBounds(true);
            clone.setDepth(2);
            clone.isClone = true;
            
            // 显示克隆特效
            createCloneEffect(clone.x, clone.y);
            
            // 添加到克隆列表
            gameState.clonedCommanders.push({
                commander: clone,
                isEnemy: false,
                createdTime: scene.time.now,
                duration: 15000,
                frozen: false
            });
        }
        
        function createCloneEffect(x, y) {
            const pos = worldToScreen(x, y);
            const effect = document.createElement('div');
            effect.className = 'arrival-effect';
            effect.style.left = `${pos.x - 40}px`;
            effect.style.top = `${pos.y - 40}px`;
            effect.style.borderColor = '#00ff9d';
            effect.style.boxShadow = `0 0 20px #00ff9d`;
            
            document.getElementById('game-canvas').parentElement.appendChild(effect);
            
            setTimeout(() => {
                effect.remove();
            }, 600);
        }
        
        function updateClonedCommanders(scene) {
            for (let i = gameState.clonedCommanders.length - 1; i >= 0; i--) {
                const clone = gameState.clonedCommanders[i];
                
                // 检查克隆是否过期
                if (scene.time.now > clone.createdTime + clone.duration) {
                    // 移除克隆
                    clone.commander.destroy();
                    gameState.clonedCommanders.splice(i, 1);
                } else {
                    // 更新克隆指挥官行为
                    updateCommander(scene, clone.commander, !clone.isEnemy);
                }
            }
        }
        
        function useShield(scene) {
            if (gameState.playerEnergy < 700 || gameState.shieldCooldown > 0) return;
            
            gameState.playerEnergy -= 700;
            gameState.shieldCooldown = 15;
            shieldCooldownIndicator.style.height = '100%';
            updateEnergyUI();
            
            // 激活基地护盾
            gameState.playerShieldActive = true;
            gameState.playerShieldEndTime = scene.time.now + 5000;
            
            // 显示护盾效果 - 完美环绕基地
            const pos = worldToScreen(playerBase.x, playerBase.y);
            const shieldRing = document.createElement('div');
            shieldRing.className = 'shield-ring';
            shieldRing.style.width = '130px';
            shieldRing.style.height = '130px';
            shieldRing.style.left = `${pos.x - 65}px`; // 居中显示
            shieldRing.style.top = `${pos.y - 65}px`; // 居中显示
            
            document.getElementById('game-canvas').parentElement.appendChild(shieldRing);
            
            // 5秒后销毁护盾
            scene.time.delayedCall(5000, () => {
                if (shieldRing) {
                    shieldRing.remove();
                }
            });
        }
        
        function useNova(scene) {
            if (gameState.playerEnergy < 1500 || gameState.novaCooldown > 0) return;
            
            gameState.playerEnergy -= 1500;
            gameState.novaCooldown = 25;
            novaCooldownIndicator.style.height = '100%';
            updateEnergyUI();
            
            // 对敌方基地造成冲击波伤害
            const distanceToEnemyBase = Phaser.Math.Distance.Between(
                playerCommander.x, playerCommander.y,
                enemyBase.x, enemyBase.y
            );
            
            // 伤害随距离衰减
            const maxDamage = 2500;
            const minDamage = 500;
            const damage = Math.max(minDamage, maxDamage - (distanceToEnemyBase / 5));
            
            gameState.enemyEnergy = Math.max(0, gameState.enemyEnergy - damage);
            updateEnergyUI();
            
            // 显示新星爆炸特效
            createNovaEffect(enemyBase.x, enemyBase.y);
        }
        
        function createNovaEffect(x, y) {
            const pos = worldToScreen(x, y);
            const explosion = document.createElement('div');
            explosion.className = 'nova-explosion';
            explosion.style.width = '100px';
            explosion.style.height = '100px';
            explosion.style.left = `${pos.x - 50}px`;
            explosion.style.top = `${pos.y - 50}px`;
            
            document.getElementById('game-canvas').parentElement.appendChild(explosion);
            
            setTimeout(() => {
                explosion.remove();
            }, 800);
        }

        function useFreeze(scene) {
            if (gameState.playerEnergy < 1000 || gameState.freezeCooldown > 0) return;
            
            gameState.playerEnergy -= 1000;
            gameState.freezeCooldown = 30;
            freezeCooldownIndicator.style.height = '100%';
            updateEnergyUI();
            
            // 冻结敌方主指挥官
            gameState.enemyFrozen = true;
            gameState.enemyFreezeEndTime = scene.time.now + 5000;
            
            // 冻结所有敌方克隆指挥官
            gameState.clonedCommanders.forEach(clone => {
                if (clone.isEnemy) {
                    clone.frozen = true;
                    clone.freezeEndTime = scene.time.now + 5000;
                    // 添加冻结特效
                    createFreezeEffect(clone.commander.x, clone.commander.y);
                }
            });
            
            // 显示冻结特效
            createFreezeEffect(enemyCommander.x, enemyCommander.y);
        }
        
        function createFreezeEffect(x, y) {
            const pos = worldToScreen(x, y);
            const freeze = document.createElement('div');
            freeze.className = 'freeze-effect';
            freeze.style.width = '70px';
            freeze.style.height = '70px';
            freeze.style.left = `${pos.x - 35}px`;
            freeze.style.top = `${pos.y - 35}px`;
            
            document.getElementById('game-canvas').parentElement.appendChild(freeze);
            
            // 5秒后销毁特效
            setTimeout(() => {
                freeze.remove();
            }, 5000);
        }
        
        function triggerRandomEvent(scene) {
            if (!gameState.gameActive) return;
            
            const events = [
                { 
                    name: 'energyStorm', 
                    title: '能量风暴', 
                    message: '所有能量核心产出翻倍！',
                    color: '#4dccff',
                    duration: 10000
                },
                { 
                    name: 'timeWarp', 
                    title: '时间扭曲', 
                    message: '指挥官移动速度大幅提升！',
                    color: '#ffcc00',
                    duration: 8000
                },
                { 
                    name: 'energyDrain', 
                    title: '能量枯竭', 
                    message: '所有核心产出减半！',
                    color: '#ff416c',
                    duration: 10000
                },
                { 
                    name: 'blackhole', 
                    title: '黑洞风暴', 
                    message: '地图中出现了额外的黑洞！',
                    color: '#9900ff',
                    duration: 0
                },
                { 
                    name: 'coreSurge', 
                    title: '核心爆发', 
                    message: '地图上出现了额外能量核心！',
                    color: '#00ff9d',
                    duration: 0
                },
                { 
                    name: 'defenseBoost', 
                    title: '防御增强', 
                    message: '玩家防御力暂时提升！',
                    color: '#4dccff',
                    duration: 8000
                },
                { 
                    name: 'attackBoost', 
                    title: '攻击强化', 
                    message: '玩家攻击力暂时提升！',
                    color: '#ff416c',
                    duration: 8000
                },
                { 
                    name: 'energyOverload', 
                    title: '能量过载', 
                    message: '红核产出增加50%！',
                    color: '#ff0000',
                    duration: 10000
                }
            ];
            
            const event = Phaser.Math.RND.pick(events);
            gameState.eventActive = event.name;
            gameState.eventEndTime = scene.time.now + event.duration;
            
            // 显示事件通知
            eventNotice.textContent = `${event.title}: ${event.message}`;
            eventNotice.style.display = 'block';
            eventNotice.style.borderColor = event.color;
            eventNotice.style.boxShadow = `0 0 15px ${event.color}`;
            
            // 应用事件效果
            switch(event.name) {
                case 'timeWarp':
                    // 加速效果
                    playerCommander.body.speed = 300;
                    enemyCommander.body.speed = 300;
                    gameState.clonedCommanders.forEach(clone => {
                        clone.commander.body.speed = 300;
                    });
                    break;
                    
                case 'defenseBoost':
                    // 临时提升防御
                    gameState.playerDefense += 2;
                    playerDefenseText.textContent = gameState.playerDefense;
                    break;
                    
                case 'attackBoost':
                    // 临时提升攻击
                    gameState.playerAttack += 2;
                    playerAttackText.textContent = gameState.playerAttack;
                    break;
                    
                case 'coreSurge':
                    // 添加额外核心
                    createEnergyCores(scene);
                    break;
                    
                case 'blackhole':
                    // 添加额外黑洞
                    createBlackholes(scene);
                    break;
            }
            
            // 隐藏通知
            scene.time.delayedCall(4000, () => {
                eventNotice.style.display = 'none';
            });
        }
        
        function updateEventStatus(scene) {
            if (gameState.eventActive && scene.time.now > gameState.eventEndTime) {
                // 结束事件效果
                switch(gameState.eventActive) {
                    case 'timeWarp':
                        // 恢复原始速度
                        playerCommander.body.speed = 150;
                        enemyCommander.body.speed = 150;
                        gameState.clonedCommanders.forEach(clone => {
                            clone.commander.body.speed = 150;
                        });
                        break;
                        
                    case 'defenseBoost':
                        gameState.playerDefense -= 2;
                        playerDefenseText.textContent = gameState.playerDefense;
                        break;
                        
                    case 'attackBoost':
                        gameState.playerAttack -= 2;
                        playerAttackText.textContent = gameState.playerAttack;
                        break;
                }
                
                gameState.eventActive = null;
            }
        }

        function updateShieldStatus(scene) {
            if (gameState.playerShieldActive && scene.time.now > gameState.playerShieldEndTime) {
                gameState.playerShieldActive = false;
            }
        }
        
        function updateFreezeStatus(scene) {
            // 更新敌方冻结状态
            if (gameState.enemyFrozen && scene.time.now > gameState.enemyFreezeEndTime) {
                gameState.enemyFrozen = false;
            }
            
            // 更新玩家冻结状态
            if (gameState.playerFrozen && scene.time.now > gameState.playerFreezeEndTime) {
                gameState.playerFrozen = false;
            }
            
            // 更新克隆指挥官冻结状态
            gameState.clonedCommanders.forEach(clone => {
                if (clone.frozen && scene.time.now > clone.freezeEndTime) {
                    clone.frozen = false;
                }
            });
        }
        
        function checkBlackholes(scene) {
            blackholes.getChildren().forEach(blackhole => {
                // 检查玩家是否在黑洞范围内
                const distanceToPlayer = Phaser.Math.Distance.Between(
                    blackhole.x, blackhole.y,
                    playerCommander.x, playerCommander.y
                );
                
                if (distanceToPlayer < 80) {
                    // 被黑洞捕获
                    teleportToRandomLocation(scene, playerCommander, true);
                }
                
                // 检查敌方是否在黑洞范围内
                const distanceToEnemy = Phaser.Math.Distance.Between(
                    blackhole.x, blackhole.y,
                    enemyCommander.x, enemyCommander.y
                );
                
                if (distanceToEnemy < 80) {
                    // 被黑洞捕获
                    teleportToRandomLocation(scene, enemyCommander, false);
                }
                
                // 检查克隆指挥官
                gameState.clonedCommanders.forEach(clone => {
                    const distanceToClone = Phaser.Math.Distance.Between(
                        blackhole.x, blackhole.y,
                        clone.commander.x, clone.commander.y
                    );
                    
                    if (distanceToClone < 80) {
                        teleportToRandomLocation(scene, clone.commander, !clone.isEnemy);
                    }
                });
            });
        }
        
        function teleportToRandomLocation(scene, commander, isPlayer) {
            // 黑洞捕获效果
            createBlackholeCaptureEffect(commander.x, commander.y);
            
            // 传送到随机位置（避免基地附近）
            let newX, newY;
            let validPosition = false;
            let attempts = 0;
            
            while (!validPosition && attempts < 20) {
                newX = Phaser.Math.Between(100, 1100);
                newY = Phaser.Math.Between(100, 600);
                
                const distToPlayerBase = Phaser.Math.Distance.Between(newX, newY, playerBase.x, playerBase.y);
                const distToEnemyBase = Phaser.Math.Distance.Between(newX, newY, enemyBase.x, enemyBase.y);
                
                if (distToPlayerBase > 150 && distToEnemyBase > 150) {
                    validPosition = true;
                }
                
                attempts++;
            }
            
            commander.x = newX;
            commander.y = newY;
            
            // 到达效果
            createArrivalEffect(newX, newY, isPlayer);
        }
        
        function createBlackholeCaptureEffect(x, y) {
            const pos = worldToScreen(x, y);
            const capture = document.createElement('div');
            capture.className = 'blackhole-capture';
            capture.style.left = `${pos.x - 25}px`;
            capture.style.top = `${pos.y - 25}px`;
            
            document.getElementById('game-canvas').parentElement.appendChild(capture);
            
            setTimeout(() => {
                capture.remove();
            }, 800);
        }
        
        function createArrivalEffect(x, y, isPlayer) {
            const pos = worldToScreen(x, y);
            const color = isPlayer ? '#4dccff' : '#ff416c';
            const effect = document.createElement('div');
            effect.className = 'arrival-effect';
            effect.style.left = `${pos.x - 25}px`;
            effect.style.top = `${pos.y - 25}px`;
            effect.style.borderColor = color;
            effect.style.boxShadow = `0 0 15px ${color}`;
            
            document.getElementById('game-canvas').parentElement.appendChild(effect);
            
            setTimeout(() => {
                effect.remove();
            }, 600);
        }
        
        // AI决策算法
        function aiUpgrade(scene) {
            if (!gameState.gameActive) return;
            
            // AI根据当前情况决策
            const playerAdvantage = gameState.playerEnergy - gameState.enemyEnergy;
            const canUpgradeAttack = gameState.enemyEnergy >= 800;
            const canUpgradeDefense = gameState.enemyEnergy >= 1000;
            
            // 如果防御等级明显低于玩家
            if (gameState.enemyDefense < gameState.playerDefense - 2 && canUpgradeDefense) {
                // 优先升级防御
                gameState.enemyEnergy -= 1000;
                gameState.enemyDefense++;
                updateEnergyUI();
            } 
            // 如果攻击等级明显低于玩家
            else if (gameState.enemyAttack < gameState.playerAttack - 2 && canUpgradeAttack) {
                // 升级攻击
                gameState.enemyEnergy -= 800;
                gameState.enemyAttack++;
                updateEnergyUI();
            }
            // 如果能量优势较大
            else if (playerAdvantage < -2000 && canUpgradeAttack) {
                // 升级攻击
                gameState.enemyEnergy -= 800;
                gameState.enemyAttack++;
                updateEnergyUI();
            }
            // 如果能量劣势较大
            else if (playerAdvantage > 2000 && canUpgradeDefense) {
                // 升级防御
                gameState.enemyEnergy -= 1000;
                gameState.enemyDefense++;
                updateEnergyUI();
            }
            // 随机选择
            else {
                if (canUpgradeAttack && canUpgradeDefense) {
                    if (Math.random() > 0.5) {
                        gameState.enemyEnergy -= 800;
                        gameState.enemyAttack++;
                        updateEnergyUI();
                    } else {
                        gameState.enemyEnergy -= 1000;
                        gameState.enemyDefense++;
                        updateEnergyUI();
                    }
                } else if (canUpgradeAttack) {
                    gameState.enemyEnergy -= 800;
                    gameState.enemyAttack++;
                    updateEnergyUI();
                } else if (canUpgradeDefense) {
                    gameState.enemyEnergy -= 1000;
                    gameState.enemyDefense++;
                    updateEnergyUI();
                }
            }
        }

        // AI技能使用
        function aiUseSkill(scene) {
            if (!gameState.gameActive) return;
            
            if (Math.random() > 0.6) return;
            
            // AI决策：根据情况选择技能
            const playerAdvantage = gameState.playerEnergy - gameState.enemyEnergy;
            const canUseFreeze = gameState.enemyEnergy >= 1000;
            const canUseNova = gameState.enemyEnergy >= 1500;
            const canUseClone = gameState.enemyEnergy >= 1200 && gameState.enemyCloneCooldown <= 0;
            const canUseShield = gameState.enemyEnergy >= 700 && gameState.enemyShieldCooldown <= 0;
            
            // 如果玩家能量优势较大
            if (playerAdvantage > 3000) {
                if (canUseFreeze) {
                    // 使用冻结技能干扰玩家
                    gameState.enemyEnergy -= 1000;
                    updateEnergyUI();
                    
                    // 显示AI技能通知
                    showAISkillNotice('敌方使用了时间冻结！');
                    
                    // 冻结玩家指挥官
                    gameState.playerFrozen = true;
                    gameState.playerFreezeEndTime = scene.time.now + 5000;
                    
                    // 冻结玩家克隆指挥官
                    gameState.clonedCommanders.forEach(clone => {
                        if (!clone.isEnemy) {
                            clone.frozen = true;
                            clone.freezeEndTime = scene.time.now + 5000;
                        }
                    });
                    
                    // 显示冻结特效
                    createFreezeEffect(playerCommander.x, playerCommander.y);
                } 
                else if (canUseClone) {
                    // 使用克隆技能
                    gameState.enemyEnergy -= 1200;
                    gameState.enemyCloneCooldown = 20;
                    updateEnergyUI();
                    
                    // 显示AI技能通知
                    showAISkillNotice('敌方使用了克隆指挥官！');
                    
                    // 创建克隆指挥官
                    const clone = scene.physics.add.sprite(
                        enemyBase.x + Phaser.Math.Between(-100, 100),
                        enemyBase.y + Phaser.Math.Between(-100, 100),
                        'clone-commander'
                    ).setTint(0xff0000).setScale(1.5);
                    clone.body.setCollideWorldBounds(true);
                    clone.isClone = true;
                    
                    // 显示克隆特效
                    createCloneEffect(clone.x, clone.y);
                    
                    // 添加到克隆列表
                    gameState.clonedCommanders.push({
                        commander: clone,
                        isEnemy: true,
                        createdTime: scene.time.now,
                        duration: 15000,
                        frozen: false
                    });
                }
            } 
            // 如果AI能量优势较大
            else if (playerAdvantage < -2000 && canUseNova) {
                // 使用能量新星
                gameState.enemyEnergy -= 1500;
                updateEnergyUI();
                
                // 显示AI技能通知
                showAISkillNotice('敌方使用了能量新星！');
                
                // 对玩家基地造成冲击波伤害
                const distanceToPlayerBase = Phaser.Math.Distance.Between(
                    enemyCommander.x, enemyCommander.y,
                    playerBase.x, playerBase.y
                );
                
                const maxDamage = 2500;
                const minDamage = 500;
                const damage = Math.max(minDamage, maxDamage - (distanceToPlayerBase / 5));
                
                gameState.playerEnergy = Math.max(0, gameState.playerEnergy - damage);
                updateEnergyUI();
                
                // 显示新星爆炸特效
                createNovaEffect(playerBase.x, playerBase.y);
            }
            // 如果防御较低
            else if (gameState.enemyDefense < gameState.playerAttack && canUseShield) {
                // 使用护盾
                gameState.enemyEnergy -= 700;
                gameState.enemyShieldCooldown = 15;
                updateEnergyUI();
                
                // 显示AI技能通知
                showAISkillNotice('敌方使用了基地护盾！');
                
                // 显示护盾效果
                const pos = worldToScreen(enemyBase.x, enemyBase.y);
                const shieldRing = document.createElement('div');
                shieldRing.className = 'shield-ring';
                shieldRing.style.width = '130px';
                shieldRing.style.height = '130px';
                shieldRing.style.left = `${pos.x - 65}px`;
                shieldRing.style.top = `${pos.y - 65}px`;
                shieldRing.style.borderColor = '#ff416c';
                shieldRing.style.boxShadow = `0 0 15px #ff416c`;
                
                document.getElementById('game-canvas').parentElement.appendChild(shieldRing);
                
                // 5秒后销毁护盾
                scene.time.delayedCall(5000, () => {
                    if (shieldRing) {
                        shieldRing.remove();
                    }
                });
            }
            // 随机使用技能
            else {
                if (canUseFreeze && Math.random() > 0.5) {
                    gameState.enemyEnergy -= 1000;
                    updateEnergyUI();
                    showAISkillNotice('敌方使用了时间冻结！');
                    gameState.playerFrozen = true;
                    gameState.playerFreezeEndTime = scene.time.now + 5000;
                    createFreezeEffect(playerCommander.x, playerCommander.y);
                } 
                else if (canUseClone) {
                    gameState.enemyEnergy -= 1200;
                    gameState.enemyCloneCooldown = 20;
                    updateEnergyUI();
                    showAISkillNotice('敌方使用了克隆指挥官！');
                    
                    const clone = scene.physics.add.sprite(
                        enemyBase.x + Phaser.Math.Between(-100, 100),
                        enemyBase.y + Phaser.Math.Between(-100, 100),
                        'clone-commander'
                    ).setTint(0xff0000).setScale(1.5);
                    clone.body.setCollideWorldBounds(true);
                    clone.isClone = true;
                    createCloneEffect(clone.x, clone.y);
                    
                    gameState.clonedCommanders.push({
                        commander: clone,
                        isEnemy: true,
                        createdTime: scene.time.now,
                        duration: 15000,
                        frozen: false
                    });
                }
                else if (canUseShield) {
                    gameState.enemyEnergy -= 700;
                    gameState.enemyShieldCooldown = 15;
                    updateEnergyUI();
                    showAISkillNotice('敌方使用了基地护盾！');
                    
                    // 显示护盾效果
                    const pos = worldToScreen(enemyBase.x, enemyBase.y);
                    const shieldRing = document.createElement('div');
                    shieldRing.className = 'shield-ring';
                    shieldRing.style.width = '130px';
                    shieldRing.style.height = '130px';
                    shieldRing.style.left = `${pos.x - 65}px`;
                    shieldRing.style.top = `${pos.y - 65}px`;
                    shieldRing.style.borderColor = '#ff416c';
                    shieldRing.style.boxShadow = `0 0 15px #ff416c`;
                    
                    document.getElementById('game-canvas').parentElement.appendChild(shieldRing);
                    
                    // 5秒后销毁护盾
                    scene.time.delayedCall(5000, () => {
                        if (shieldRing) {
                            shieldRing.remove();
                        }
                    });
                }
                else if (canUseNova) {
                    gameState.enemyEnergy -= 1500;
                    updateEnergyUI();
                    showAISkillNotice('敌方使用了能量新星！');
                    
                    const distanceToPlayerBase = Phaser.Math.Distance.Between(
                        enemyCommander.x, enemyCommander.y,
                        playerBase.x, playerBase.y
                    );
                    
                    const maxDamage = 2500;
                    const minDamage = 500;
                    const damage = Math.max(minDamage, maxDamage - (distanceToPlayerBase / 5));
                    
                    gameState.playerEnergy = Math.max(0, gameState.playerEnergy - damage);
                    updateEnergyUI();
                    
                    // 显示新星爆炸特效
                    createNovaEffect(playerBase.x, playerBase.y);
                }
            }
        }

        function showAISkillNotice(message) {
            aiSkillNotice.textContent = message;
            aiSkillNotice.style.display = 'block';
            
            // 3秒后隐藏通知
            setTimeout(() => {
                aiSkillNotice.style.display = 'none';
            }, 3000);
        }
        
        function endGame(title, message) {
            gameState.gameActive = false;
            
            document.getElementById('message-title').textContent = title;
            document.getElementById('message-content').textContent = message;
            document.getElementById('message').style.display = 'block';
        }
        
        function restartGame() {
            location.reload();
        }
        
        // 初始化加载
        document.addEventListener('DOMContentLoaded', preloadResources);
    </script>
</body>
</html>
